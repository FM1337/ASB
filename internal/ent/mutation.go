// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/FM1337/ASB/internal/ent/cooldown"
	"github.com/FM1337/ASB/internal/ent/predicate"
	"github.com/FM1337/ASB/internal/ent/server"
	"github.com/FM1337/ASB/internal/ent/serverconfig"
	"github.com/FM1337/ASB/internal/ent/spammer"
	"github.com/FM1337/ASB/internal/ent/wordblacklist"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCooldown      = "Cooldown"
	TypeServer        = "Server"
	TypeServerConfig  = "ServerConfig"
	TypeSpammer       = "Spammer"
	TypeWordBlacklist = "WordBlacklist"
)

// CooldownMutation represents an operation that mutates the Cooldown nodes in the graph.
type CooldownMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	user_id       *string
	hash          *string
	count         *int
	addcount      *int
	resets_at     *time.Time
	clearedFields map[string]struct{}
	server        *int
	clearedserver bool
	done          bool
	oldValue      func(context.Context) (*Cooldown, error)
	predicates    []predicate.Cooldown
}

var _ ent.Mutation = (*CooldownMutation)(nil)

// cooldownOption allows management of the mutation configuration using functional options.
type cooldownOption func(*CooldownMutation)

// newCooldownMutation creates new mutation for the Cooldown entity.
func newCooldownMutation(c config, op Op, opts ...cooldownOption) *CooldownMutation {
	m := &CooldownMutation{
		config:        c,
		op:            op,
		typ:           TypeCooldown,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCooldownID sets the ID field of the mutation.
func withCooldownID(id int) cooldownOption {
	return func(m *CooldownMutation) {
		var (
			err   error
			once  sync.Once
			value *Cooldown
		)
		m.oldValue = func(ctx context.Context) (*Cooldown, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cooldown.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCooldown sets the old Cooldown of the mutation.
func withCooldown(node *Cooldown) cooldownOption {
	return func(m *CooldownMutation) {
		m.oldValue = func(context.Context) (*Cooldown, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CooldownMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CooldownMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CooldownMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CooldownMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cooldown.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CooldownMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CooldownMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Cooldown entity.
// If the Cooldown object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooldownMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CooldownMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CooldownMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CooldownMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Cooldown entity.
// If the Cooldown object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooldownMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CooldownMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUserID sets the "user_id" field.
func (m *CooldownMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CooldownMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Cooldown entity.
// If the Cooldown object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooldownMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CooldownMutation) ResetUserID() {
	m.user_id = nil
}

// SetHash sets the "hash" field.
func (m *CooldownMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *CooldownMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Cooldown entity.
// If the Cooldown object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooldownMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *CooldownMutation) ResetHash() {
	m.hash = nil
}

// SetCount sets the "count" field.
func (m *CooldownMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *CooldownMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the Cooldown entity.
// If the Cooldown object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooldownMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *CooldownMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *CooldownMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *CooldownMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetResetsAt sets the "resets_at" field.
func (m *CooldownMutation) SetResetsAt(t time.Time) {
	m.resets_at = &t
}

// ResetsAt returns the value of the "resets_at" field in the mutation.
func (m *CooldownMutation) ResetsAt() (r time.Time, exists bool) {
	v := m.resets_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResetsAt returns the old "resets_at" field's value of the Cooldown entity.
// If the Cooldown object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooldownMutation) OldResetsAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetsAt: %w", err)
	}
	return oldValue.ResetsAt, nil
}

// ResetResetsAt resets all changes to the "resets_at" field.
func (m *CooldownMutation) ResetResetsAt() {
	m.resets_at = nil
}

// SetServerID sets the "server" edge to the Server entity by id.
func (m *CooldownMutation) SetServerID(id int) {
	m.server = &id
}

// ClearServer clears the "server" edge to the Server entity.
func (m *CooldownMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *CooldownMutation) ServerCleared() bool {
	return m.clearedserver
}

// ServerID returns the "server" edge ID in the mutation.
func (m *CooldownMutation) ServerID() (id int, exists bool) {
	if m.server != nil {
		return *m.server, true
	}
	return
}

// ServerIDs returns the "server" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerID instead. It exists only for internal usage by the builders.
func (m *CooldownMutation) ServerIDs() (ids []int) {
	if id := m.server; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *CooldownMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
}

// Where appends a list predicates to the CooldownMutation builder.
func (m *CooldownMutation) Where(ps ...predicate.Cooldown) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CooldownMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CooldownMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Cooldown, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CooldownMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CooldownMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Cooldown).
func (m *CooldownMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CooldownMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, cooldown.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, cooldown.FieldUpdateTime)
	}
	if m.user_id != nil {
		fields = append(fields, cooldown.FieldUserID)
	}
	if m.hash != nil {
		fields = append(fields, cooldown.FieldHash)
	}
	if m.count != nil {
		fields = append(fields, cooldown.FieldCount)
	}
	if m.resets_at != nil {
		fields = append(fields, cooldown.FieldResetsAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CooldownMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cooldown.FieldCreateTime:
		return m.CreateTime()
	case cooldown.FieldUpdateTime:
		return m.UpdateTime()
	case cooldown.FieldUserID:
		return m.UserID()
	case cooldown.FieldHash:
		return m.Hash()
	case cooldown.FieldCount:
		return m.Count()
	case cooldown.FieldResetsAt:
		return m.ResetsAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CooldownMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cooldown.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case cooldown.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case cooldown.FieldUserID:
		return m.OldUserID(ctx)
	case cooldown.FieldHash:
		return m.OldHash(ctx)
	case cooldown.FieldCount:
		return m.OldCount(ctx)
	case cooldown.FieldResetsAt:
		return m.OldResetsAt(ctx)
	}
	return nil, fmt.Errorf("unknown Cooldown field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CooldownMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cooldown.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case cooldown.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case cooldown.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case cooldown.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case cooldown.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case cooldown.FieldResetsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetsAt(v)
		return nil
	}
	return fmt.Errorf("unknown Cooldown field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CooldownMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, cooldown.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CooldownMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cooldown.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CooldownMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cooldown.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown Cooldown numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CooldownMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CooldownMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CooldownMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cooldown nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CooldownMutation) ResetField(name string) error {
	switch name {
	case cooldown.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case cooldown.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case cooldown.FieldUserID:
		m.ResetUserID()
		return nil
	case cooldown.FieldHash:
		m.ResetHash()
		return nil
	case cooldown.FieldCount:
		m.ResetCount()
		return nil
	case cooldown.FieldResetsAt:
		m.ResetResetsAt()
		return nil
	}
	return fmt.Errorf("unknown Cooldown field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CooldownMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.server != nil {
		edges = append(edges, cooldown.EdgeServer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CooldownMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cooldown.EdgeServer:
		if id := m.server; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CooldownMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CooldownMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CooldownMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedserver {
		edges = append(edges, cooldown.EdgeServer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CooldownMutation) EdgeCleared(name string) bool {
	switch name {
	case cooldown.EdgeServer:
		return m.clearedserver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CooldownMutation) ClearEdge(name string) error {
	switch name {
	case cooldown.EdgeServer:
		m.ClearServer()
		return nil
	}
	return fmt.Errorf("unknown Cooldown unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CooldownMutation) ResetEdge(name string) error {
	switch name {
	case cooldown.EdgeServer:
		m.ResetServer()
		return nil
	}
	return fmt.Errorf("unknown Cooldown edge %s", name)
}

// ServerMutation represents an operation that mutates the Server nodes in the graph.
type ServerMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	server_id             *string
	owner_id              *string
	enabled               *bool
	clearedFields         map[string]struct{}
	configuration         *int
	clearedconfiguration  bool
	spammer               *int
	clearedspammer        bool
	word_blacklist        map[int]struct{}
	removedword_blacklist map[int]struct{}
	clearedword_blacklist bool
	cooldown              map[int]struct{}
	removedcooldown       map[int]struct{}
	clearedcooldown       bool
	done                  bool
	oldValue              func(context.Context) (*Server, error)
	predicates            []predicate.Server
}

var _ ent.Mutation = (*ServerMutation)(nil)

// serverOption allows management of the mutation configuration using functional options.
type serverOption func(*ServerMutation)

// newServerMutation creates new mutation for the Server entity.
func newServerMutation(c config, op Op, opts ...serverOption) *ServerMutation {
	m := &ServerMutation{
		config:        c,
		op:            op,
		typ:           TypeServer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerID sets the ID field of the mutation.
func withServerID(id int) serverOption {
	return func(m *ServerMutation) {
		var (
			err   error
			once  sync.Once
			value *Server
		)
		m.oldValue = func(ctx context.Context) (*Server, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Server.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServer sets the old Server of the mutation.
func withServer(node *Server) serverOption {
	return func(m *ServerMutation) {
		m.oldValue = func(context.Context) (*Server, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Server.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServerMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServerMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServerMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ServerMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ServerMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ServerMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetServerID sets the "server_id" field.
func (m *ServerMutation) SetServerID(s string) {
	m.server_id = &s
}

// ServerID returns the value of the "server_id" field in the mutation.
func (m *ServerMutation) ServerID() (r string, exists bool) {
	v := m.server_id
	if v == nil {
		return
	}
	return *v, true
}

// OldServerID returns the old "server_id" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldServerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerID: %w", err)
	}
	return oldValue.ServerID, nil
}

// ResetServerID resets all changes to the "server_id" field.
func (m *ServerMutation) ResetServerID() {
	m.server_id = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *ServerMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ServerMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ServerMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetEnabled sets the "enabled" field.
func (m *ServerMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ServerMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ServerMutation) ResetEnabled() {
	m.enabled = nil
}

// SetConfigurationID sets the "configuration" edge to the ServerConfig entity by id.
func (m *ServerMutation) SetConfigurationID(id int) {
	m.configuration = &id
}

// ClearConfiguration clears the "configuration" edge to the ServerConfig entity.
func (m *ServerMutation) ClearConfiguration() {
	m.clearedconfiguration = true
}

// ConfigurationCleared reports if the "configuration" edge to the ServerConfig entity was cleared.
func (m *ServerMutation) ConfigurationCleared() bool {
	return m.clearedconfiguration
}

// ConfigurationID returns the "configuration" edge ID in the mutation.
func (m *ServerMutation) ConfigurationID() (id int, exists bool) {
	if m.configuration != nil {
		return *m.configuration, true
	}
	return
}

// ConfigurationIDs returns the "configuration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConfigurationID instead. It exists only for internal usage by the builders.
func (m *ServerMutation) ConfigurationIDs() (ids []int) {
	if id := m.configuration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfiguration resets all changes to the "configuration" edge.
func (m *ServerMutation) ResetConfiguration() {
	m.configuration = nil
	m.clearedconfiguration = false
}

// SetSpammerID sets the "spammer" edge to the Spammer entity by id.
func (m *ServerMutation) SetSpammerID(id int) {
	m.spammer = &id
}

// ClearSpammer clears the "spammer" edge to the Spammer entity.
func (m *ServerMutation) ClearSpammer() {
	m.clearedspammer = true
}

// SpammerCleared reports if the "spammer" edge to the Spammer entity was cleared.
func (m *ServerMutation) SpammerCleared() bool {
	return m.clearedspammer
}

// SpammerID returns the "spammer" edge ID in the mutation.
func (m *ServerMutation) SpammerID() (id int, exists bool) {
	if m.spammer != nil {
		return *m.spammer, true
	}
	return
}

// SpammerIDs returns the "spammer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpammerID instead. It exists only for internal usage by the builders.
func (m *ServerMutation) SpammerIDs() (ids []int) {
	if id := m.spammer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpammer resets all changes to the "spammer" edge.
func (m *ServerMutation) ResetSpammer() {
	m.spammer = nil
	m.clearedspammer = false
}

// AddWordBlacklistIDs adds the "word_blacklist" edge to the WordBlacklist entity by ids.
func (m *ServerMutation) AddWordBlacklistIDs(ids ...int) {
	if m.word_blacklist == nil {
		m.word_blacklist = make(map[int]struct{})
	}
	for i := range ids {
		m.word_blacklist[ids[i]] = struct{}{}
	}
}

// ClearWordBlacklist clears the "word_blacklist" edge to the WordBlacklist entity.
func (m *ServerMutation) ClearWordBlacklist() {
	m.clearedword_blacklist = true
}

// WordBlacklistCleared reports if the "word_blacklist" edge to the WordBlacklist entity was cleared.
func (m *ServerMutation) WordBlacklistCleared() bool {
	return m.clearedword_blacklist
}

// RemoveWordBlacklistIDs removes the "word_blacklist" edge to the WordBlacklist entity by IDs.
func (m *ServerMutation) RemoveWordBlacklistIDs(ids ...int) {
	if m.removedword_blacklist == nil {
		m.removedword_blacklist = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.word_blacklist, ids[i])
		m.removedword_blacklist[ids[i]] = struct{}{}
	}
}

// RemovedWordBlacklist returns the removed IDs of the "word_blacklist" edge to the WordBlacklist entity.
func (m *ServerMutation) RemovedWordBlacklistIDs() (ids []int) {
	for id := range m.removedword_blacklist {
		ids = append(ids, id)
	}
	return
}

// WordBlacklistIDs returns the "word_blacklist" edge IDs in the mutation.
func (m *ServerMutation) WordBlacklistIDs() (ids []int) {
	for id := range m.word_blacklist {
		ids = append(ids, id)
	}
	return
}

// ResetWordBlacklist resets all changes to the "word_blacklist" edge.
func (m *ServerMutation) ResetWordBlacklist() {
	m.word_blacklist = nil
	m.clearedword_blacklist = false
	m.removedword_blacklist = nil
}

// AddCooldownIDs adds the "cooldown" edge to the Cooldown entity by ids.
func (m *ServerMutation) AddCooldownIDs(ids ...int) {
	if m.cooldown == nil {
		m.cooldown = make(map[int]struct{})
	}
	for i := range ids {
		m.cooldown[ids[i]] = struct{}{}
	}
}

// ClearCooldown clears the "cooldown" edge to the Cooldown entity.
func (m *ServerMutation) ClearCooldown() {
	m.clearedcooldown = true
}

// CooldownCleared reports if the "cooldown" edge to the Cooldown entity was cleared.
func (m *ServerMutation) CooldownCleared() bool {
	return m.clearedcooldown
}

// RemoveCooldownIDs removes the "cooldown" edge to the Cooldown entity by IDs.
func (m *ServerMutation) RemoveCooldownIDs(ids ...int) {
	if m.removedcooldown == nil {
		m.removedcooldown = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cooldown, ids[i])
		m.removedcooldown[ids[i]] = struct{}{}
	}
}

// RemovedCooldown returns the removed IDs of the "cooldown" edge to the Cooldown entity.
func (m *ServerMutation) RemovedCooldownIDs() (ids []int) {
	for id := range m.removedcooldown {
		ids = append(ids, id)
	}
	return
}

// CooldownIDs returns the "cooldown" edge IDs in the mutation.
func (m *ServerMutation) CooldownIDs() (ids []int) {
	for id := range m.cooldown {
		ids = append(ids, id)
	}
	return
}

// ResetCooldown resets all changes to the "cooldown" edge.
func (m *ServerMutation) ResetCooldown() {
	m.cooldown = nil
	m.clearedcooldown = false
	m.removedcooldown = nil
}

// Where appends a list predicates to the ServerMutation builder.
func (m *ServerMutation) Where(ps ...predicate.Server) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Server, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Server).
func (m *ServerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, server.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, server.FieldUpdateTime)
	}
	if m.server_id != nil {
		fields = append(fields, server.FieldServerID)
	}
	if m.owner_id != nil {
		fields = append(fields, server.FieldOwnerID)
	}
	if m.enabled != nil {
		fields = append(fields, server.FieldEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case server.FieldCreateTime:
		return m.CreateTime()
	case server.FieldUpdateTime:
		return m.UpdateTime()
	case server.FieldServerID:
		return m.ServerID()
	case server.FieldOwnerID:
		return m.OwnerID()
	case server.FieldEnabled:
		return m.Enabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case server.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case server.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case server.FieldServerID:
		return m.OldServerID(ctx)
	case server.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case server.FieldEnabled:
		return m.OldEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown Server field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case server.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case server.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case server.FieldServerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerID(v)
		return nil
	case server.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case server.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Server numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Server nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerMutation) ResetField(name string) error {
	switch name {
	case server.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case server.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case server.FieldServerID:
		m.ResetServerID()
		return nil
	case server.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case server.FieldEnabled:
		m.ResetEnabled()
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.configuration != nil {
		edges = append(edges, server.EdgeConfiguration)
	}
	if m.spammer != nil {
		edges = append(edges, server.EdgeSpammer)
	}
	if m.word_blacklist != nil {
		edges = append(edges, server.EdgeWordBlacklist)
	}
	if m.cooldown != nil {
		edges = append(edges, server.EdgeCooldown)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case server.EdgeConfiguration:
		if id := m.configuration; id != nil {
			return []ent.Value{*id}
		}
	case server.EdgeSpammer:
		if id := m.spammer; id != nil {
			return []ent.Value{*id}
		}
	case server.EdgeWordBlacklist:
		ids := make([]ent.Value, 0, len(m.word_blacklist))
		for id := range m.word_blacklist {
			ids = append(ids, id)
		}
		return ids
	case server.EdgeCooldown:
		ids := make([]ent.Value, 0, len(m.cooldown))
		for id := range m.cooldown {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedword_blacklist != nil {
		edges = append(edges, server.EdgeWordBlacklist)
	}
	if m.removedcooldown != nil {
		edges = append(edges, server.EdgeCooldown)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case server.EdgeWordBlacklist:
		ids := make([]ent.Value, 0, len(m.removedword_blacklist))
		for id := range m.removedword_blacklist {
			ids = append(ids, id)
		}
		return ids
	case server.EdgeCooldown:
		ids := make([]ent.Value, 0, len(m.removedcooldown))
		for id := range m.removedcooldown {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedconfiguration {
		edges = append(edges, server.EdgeConfiguration)
	}
	if m.clearedspammer {
		edges = append(edges, server.EdgeSpammer)
	}
	if m.clearedword_blacklist {
		edges = append(edges, server.EdgeWordBlacklist)
	}
	if m.clearedcooldown {
		edges = append(edges, server.EdgeCooldown)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerMutation) EdgeCleared(name string) bool {
	switch name {
	case server.EdgeConfiguration:
		return m.clearedconfiguration
	case server.EdgeSpammer:
		return m.clearedspammer
	case server.EdgeWordBlacklist:
		return m.clearedword_blacklist
	case server.EdgeCooldown:
		return m.clearedcooldown
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerMutation) ClearEdge(name string) error {
	switch name {
	case server.EdgeConfiguration:
		m.ClearConfiguration()
		return nil
	case server.EdgeSpammer:
		m.ClearSpammer()
		return nil
	}
	return fmt.Errorf("unknown Server unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerMutation) ResetEdge(name string) error {
	switch name {
	case server.EdgeConfiguration:
		m.ResetConfiguration()
		return nil
	case server.EdgeSpammer:
		m.ResetSpammer()
		return nil
	case server.EdgeWordBlacklist:
		m.ResetWordBlacklist()
		return nil
	case server.EdgeCooldown:
		m.ResetCooldown()
		return nil
	}
	return fmt.Errorf("unknown Server edge %s", name)
}

// ServerConfigMutation represents an operation that mutates the ServerConfig nodes in the graph.
type ServerConfigMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	remove_roles            *bool
	give_role               *bool
	timeout                 *bool
	kick                    *bool
	ban                     *bool
	check_invites           *bool
	check_links             *bool
	ratelimit               *bool
	alerts                  *bool
	flag_links              *bool
	log_channel             *string
	given_role              *string
	excluded_channels       *[]string
	appendexcluded_channels []string
	excluded_roles          *[]string
	appendexcluded_roles    []string
	excluded_users          *[]string
	appendexcluded_users    []string
	ratelimit_message       *int
	addratelimit_message    *int
	ratelimit_time          *serverconfig.RatelimitTime
	timeout_time            *serverconfig.TimeoutTime
	ban_delete_message_time *serverconfig.BanDeleteMessageTime
	clearedFields           map[string]struct{}
	server                  *int
	clearedserver           bool
	done                    bool
	oldValue                func(context.Context) (*ServerConfig, error)
	predicates              []predicate.ServerConfig
}

var _ ent.Mutation = (*ServerConfigMutation)(nil)

// serverconfigOption allows management of the mutation configuration using functional options.
type serverconfigOption func(*ServerConfigMutation)

// newServerConfigMutation creates new mutation for the ServerConfig entity.
func newServerConfigMutation(c config, op Op, opts ...serverconfigOption) *ServerConfigMutation {
	m := &ServerConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeServerConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerConfigID sets the ID field of the mutation.
func withServerConfigID(id int) serverconfigOption {
	return func(m *ServerConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerConfig
		)
		m.oldValue = func(ctx context.Context) (*ServerConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerConfig sets the old ServerConfig of the mutation.
func withServerConfig(node *ServerConfig) serverconfigOption {
	return func(m *ServerConfigMutation) {
		m.oldValue = func(context.Context) (*ServerConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServerConfigMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServerConfigMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServerConfigMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ServerConfigMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ServerConfigMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ServerConfigMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetRemoveRoles sets the "remove_roles" field.
func (m *ServerConfigMutation) SetRemoveRoles(b bool) {
	m.remove_roles = &b
}

// RemoveRoles returns the value of the "remove_roles" field in the mutation.
func (m *ServerConfigMutation) RemoveRoles() (r bool, exists bool) {
	v := m.remove_roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoveRoles returns the old "remove_roles" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldRemoveRoles(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoveRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoveRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoveRoles: %w", err)
	}
	return oldValue.RemoveRoles, nil
}

// ResetRemoveRoles resets all changes to the "remove_roles" field.
func (m *ServerConfigMutation) ResetRemoveRoles() {
	m.remove_roles = nil
}

// SetGiveRole sets the "give_role" field.
func (m *ServerConfigMutation) SetGiveRole(b bool) {
	m.give_role = &b
}

// GiveRole returns the value of the "give_role" field in the mutation.
func (m *ServerConfigMutation) GiveRole() (r bool, exists bool) {
	v := m.give_role
	if v == nil {
		return
	}
	return *v, true
}

// OldGiveRole returns the old "give_role" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldGiveRole(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiveRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiveRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiveRole: %w", err)
	}
	return oldValue.GiveRole, nil
}

// ResetGiveRole resets all changes to the "give_role" field.
func (m *ServerConfigMutation) ResetGiveRole() {
	m.give_role = nil
}

// SetTimeout sets the "timeout" field.
func (m *ServerConfigMutation) SetTimeout(b bool) {
	m.timeout = &b
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *ServerConfigMutation) Timeout() (r bool, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldTimeout(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *ServerConfigMutation) ResetTimeout() {
	m.timeout = nil
}

// SetKick sets the "kick" field.
func (m *ServerConfigMutation) SetKick(b bool) {
	m.kick = &b
}

// Kick returns the value of the "kick" field in the mutation.
func (m *ServerConfigMutation) Kick() (r bool, exists bool) {
	v := m.kick
	if v == nil {
		return
	}
	return *v, true
}

// OldKick returns the old "kick" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldKick(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKick is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKick requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKick: %w", err)
	}
	return oldValue.Kick, nil
}

// ResetKick resets all changes to the "kick" field.
func (m *ServerConfigMutation) ResetKick() {
	m.kick = nil
}

// SetBan sets the "ban" field.
func (m *ServerConfigMutation) SetBan(b bool) {
	m.ban = &b
}

// Ban returns the value of the "ban" field in the mutation.
func (m *ServerConfigMutation) Ban() (r bool, exists bool) {
	v := m.ban
	if v == nil {
		return
	}
	return *v, true
}

// OldBan returns the old "ban" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldBan(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBan: %w", err)
	}
	return oldValue.Ban, nil
}

// ResetBan resets all changes to the "ban" field.
func (m *ServerConfigMutation) ResetBan() {
	m.ban = nil
}

// SetCheckInvites sets the "check_invites" field.
func (m *ServerConfigMutation) SetCheckInvites(b bool) {
	m.check_invites = &b
}

// CheckInvites returns the value of the "check_invites" field in the mutation.
func (m *ServerConfigMutation) CheckInvites() (r bool, exists bool) {
	v := m.check_invites
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckInvites returns the old "check_invites" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldCheckInvites(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckInvites is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckInvites requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckInvites: %w", err)
	}
	return oldValue.CheckInvites, nil
}

// ResetCheckInvites resets all changes to the "check_invites" field.
func (m *ServerConfigMutation) ResetCheckInvites() {
	m.check_invites = nil
}

// SetCheckLinks sets the "check_links" field.
func (m *ServerConfigMutation) SetCheckLinks(b bool) {
	m.check_links = &b
}

// CheckLinks returns the value of the "check_links" field in the mutation.
func (m *ServerConfigMutation) CheckLinks() (r bool, exists bool) {
	v := m.check_links
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckLinks returns the old "check_links" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldCheckLinks(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckLinks: %w", err)
	}
	return oldValue.CheckLinks, nil
}

// ResetCheckLinks resets all changes to the "check_links" field.
func (m *ServerConfigMutation) ResetCheckLinks() {
	m.check_links = nil
}

// SetRatelimit sets the "ratelimit" field.
func (m *ServerConfigMutation) SetRatelimit(b bool) {
	m.ratelimit = &b
}

// Ratelimit returns the value of the "ratelimit" field in the mutation.
func (m *ServerConfigMutation) Ratelimit() (r bool, exists bool) {
	v := m.ratelimit
	if v == nil {
		return
	}
	return *v, true
}

// OldRatelimit returns the old "ratelimit" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldRatelimit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatelimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatelimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatelimit: %w", err)
	}
	return oldValue.Ratelimit, nil
}

// ResetRatelimit resets all changes to the "ratelimit" field.
func (m *ServerConfigMutation) ResetRatelimit() {
	m.ratelimit = nil
}

// SetAlerts sets the "alerts" field.
func (m *ServerConfigMutation) SetAlerts(b bool) {
	m.alerts = &b
}

// Alerts returns the value of the "alerts" field in the mutation.
func (m *ServerConfigMutation) Alerts() (r bool, exists bool) {
	v := m.alerts
	if v == nil {
		return
	}
	return *v, true
}

// OldAlerts returns the old "alerts" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldAlerts(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlerts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlerts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlerts: %w", err)
	}
	return oldValue.Alerts, nil
}

// ResetAlerts resets all changes to the "alerts" field.
func (m *ServerConfigMutation) ResetAlerts() {
	m.alerts = nil
}

// SetFlagLinks sets the "flag_links" field.
func (m *ServerConfigMutation) SetFlagLinks(b bool) {
	m.flag_links = &b
}

// FlagLinks returns the value of the "flag_links" field in the mutation.
func (m *ServerConfigMutation) FlagLinks() (r bool, exists bool) {
	v := m.flag_links
	if v == nil {
		return
	}
	return *v, true
}

// OldFlagLinks returns the old "flag_links" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldFlagLinks(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlagLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlagLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlagLinks: %w", err)
	}
	return oldValue.FlagLinks, nil
}

// ResetFlagLinks resets all changes to the "flag_links" field.
func (m *ServerConfigMutation) ResetFlagLinks() {
	m.flag_links = nil
}

// SetLogChannel sets the "log_channel" field.
func (m *ServerConfigMutation) SetLogChannel(s string) {
	m.log_channel = &s
}

// LogChannel returns the value of the "log_channel" field in the mutation.
func (m *ServerConfigMutation) LogChannel() (r string, exists bool) {
	v := m.log_channel
	if v == nil {
		return
	}
	return *v, true
}

// OldLogChannel returns the old "log_channel" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldLogChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogChannel: %w", err)
	}
	return oldValue.LogChannel, nil
}

// ResetLogChannel resets all changes to the "log_channel" field.
func (m *ServerConfigMutation) ResetLogChannel() {
	m.log_channel = nil
}

// SetGivenRole sets the "given_role" field.
func (m *ServerConfigMutation) SetGivenRole(s string) {
	m.given_role = &s
}

// GivenRole returns the value of the "given_role" field in the mutation.
func (m *ServerConfigMutation) GivenRole() (r string, exists bool) {
	v := m.given_role
	if v == nil {
		return
	}
	return *v, true
}

// OldGivenRole returns the old "given_role" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldGivenRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGivenRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGivenRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGivenRole: %w", err)
	}
	return oldValue.GivenRole, nil
}

// ResetGivenRole resets all changes to the "given_role" field.
func (m *ServerConfigMutation) ResetGivenRole() {
	m.given_role = nil
}

// SetExcludedChannels sets the "excluded_channels" field.
func (m *ServerConfigMutation) SetExcludedChannels(s []string) {
	m.excluded_channels = &s
	m.appendexcluded_channels = nil
}

// ExcludedChannels returns the value of the "excluded_channels" field in the mutation.
func (m *ServerConfigMutation) ExcludedChannels() (r []string, exists bool) {
	v := m.excluded_channels
	if v == nil {
		return
	}
	return *v, true
}

// OldExcludedChannels returns the old "excluded_channels" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldExcludedChannels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcludedChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcludedChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcludedChannels: %w", err)
	}
	return oldValue.ExcludedChannels, nil
}

// AppendExcludedChannels adds s to the "excluded_channels" field.
func (m *ServerConfigMutation) AppendExcludedChannels(s []string) {
	m.appendexcluded_channels = append(m.appendexcluded_channels, s...)
}

// AppendedExcludedChannels returns the list of values that were appended to the "excluded_channels" field in this mutation.
func (m *ServerConfigMutation) AppendedExcludedChannels() ([]string, bool) {
	if len(m.appendexcluded_channels) == 0 {
		return nil, false
	}
	return m.appendexcluded_channels, true
}

// ResetExcludedChannels resets all changes to the "excluded_channels" field.
func (m *ServerConfigMutation) ResetExcludedChannels() {
	m.excluded_channels = nil
	m.appendexcluded_channels = nil
}

// SetExcludedRoles sets the "excluded_roles" field.
func (m *ServerConfigMutation) SetExcludedRoles(s []string) {
	m.excluded_roles = &s
	m.appendexcluded_roles = nil
}

// ExcludedRoles returns the value of the "excluded_roles" field in the mutation.
func (m *ServerConfigMutation) ExcludedRoles() (r []string, exists bool) {
	v := m.excluded_roles
	if v == nil {
		return
	}
	return *v, true
}

// OldExcludedRoles returns the old "excluded_roles" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldExcludedRoles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcludedRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcludedRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcludedRoles: %w", err)
	}
	return oldValue.ExcludedRoles, nil
}

// AppendExcludedRoles adds s to the "excluded_roles" field.
func (m *ServerConfigMutation) AppendExcludedRoles(s []string) {
	m.appendexcluded_roles = append(m.appendexcluded_roles, s...)
}

// AppendedExcludedRoles returns the list of values that were appended to the "excluded_roles" field in this mutation.
func (m *ServerConfigMutation) AppendedExcludedRoles() ([]string, bool) {
	if len(m.appendexcluded_roles) == 0 {
		return nil, false
	}
	return m.appendexcluded_roles, true
}

// ResetExcludedRoles resets all changes to the "excluded_roles" field.
func (m *ServerConfigMutation) ResetExcludedRoles() {
	m.excluded_roles = nil
	m.appendexcluded_roles = nil
}

// SetExcludedUsers sets the "excluded_users" field.
func (m *ServerConfigMutation) SetExcludedUsers(s []string) {
	m.excluded_users = &s
	m.appendexcluded_users = nil
}

// ExcludedUsers returns the value of the "excluded_users" field in the mutation.
func (m *ServerConfigMutation) ExcludedUsers() (r []string, exists bool) {
	v := m.excluded_users
	if v == nil {
		return
	}
	return *v, true
}

// OldExcludedUsers returns the old "excluded_users" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldExcludedUsers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcludedUsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcludedUsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcludedUsers: %w", err)
	}
	return oldValue.ExcludedUsers, nil
}

// AppendExcludedUsers adds s to the "excluded_users" field.
func (m *ServerConfigMutation) AppendExcludedUsers(s []string) {
	m.appendexcluded_users = append(m.appendexcluded_users, s...)
}

// AppendedExcludedUsers returns the list of values that were appended to the "excluded_users" field in this mutation.
func (m *ServerConfigMutation) AppendedExcludedUsers() ([]string, bool) {
	if len(m.appendexcluded_users) == 0 {
		return nil, false
	}
	return m.appendexcluded_users, true
}

// ResetExcludedUsers resets all changes to the "excluded_users" field.
func (m *ServerConfigMutation) ResetExcludedUsers() {
	m.excluded_users = nil
	m.appendexcluded_users = nil
}

// SetRatelimitMessage sets the "ratelimit_message" field.
func (m *ServerConfigMutation) SetRatelimitMessage(i int) {
	m.ratelimit_message = &i
	m.addratelimit_message = nil
}

// RatelimitMessage returns the value of the "ratelimit_message" field in the mutation.
func (m *ServerConfigMutation) RatelimitMessage() (r int, exists bool) {
	v := m.ratelimit_message
	if v == nil {
		return
	}
	return *v, true
}

// OldRatelimitMessage returns the old "ratelimit_message" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldRatelimitMessage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatelimitMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatelimitMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatelimitMessage: %w", err)
	}
	return oldValue.RatelimitMessage, nil
}

// AddRatelimitMessage adds i to the "ratelimit_message" field.
func (m *ServerConfigMutation) AddRatelimitMessage(i int) {
	if m.addratelimit_message != nil {
		*m.addratelimit_message += i
	} else {
		m.addratelimit_message = &i
	}
}

// AddedRatelimitMessage returns the value that was added to the "ratelimit_message" field in this mutation.
func (m *ServerConfigMutation) AddedRatelimitMessage() (r int, exists bool) {
	v := m.addratelimit_message
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatelimitMessage resets all changes to the "ratelimit_message" field.
func (m *ServerConfigMutation) ResetRatelimitMessage() {
	m.ratelimit_message = nil
	m.addratelimit_message = nil
}

// SetRatelimitTime sets the "ratelimit_time" field.
func (m *ServerConfigMutation) SetRatelimitTime(st serverconfig.RatelimitTime) {
	m.ratelimit_time = &st
}

// RatelimitTime returns the value of the "ratelimit_time" field in the mutation.
func (m *ServerConfigMutation) RatelimitTime() (r serverconfig.RatelimitTime, exists bool) {
	v := m.ratelimit_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRatelimitTime returns the old "ratelimit_time" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldRatelimitTime(ctx context.Context) (v serverconfig.RatelimitTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatelimitTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatelimitTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatelimitTime: %w", err)
	}
	return oldValue.RatelimitTime, nil
}

// ResetRatelimitTime resets all changes to the "ratelimit_time" field.
func (m *ServerConfigMutation) ResetRatelimitTime() {
	m.ratelimit_time = nil
}

// SetTimeoutTime sets the "timeout_time" field.
func (m *ServerConfigMutation) SetTimeoutTime(st serverconfig.TimeoutTime) {
	m.timeout_time = &st
}

// TimeoutTime returns the value of the "timeout_time" field in the mutation.
func (m *ServerConfigMutation) TimeoutTime() (r serverconfig.TimeoutTime, exists bool) {
	v := m.timeout_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeoutTime returns the old "timeout_time" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldTimeoutTime(ctx context.Context) (v serverconfig.TimeoutTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeoutTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeoutTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeoutTime: %w", err)
	}
	return oldValue.TimeoutTime, nil
}

// ResetTimeoutTime resets all changes to the "timeout_time" field.
func (m *ServerConfigMutation) ResetTimeoutTime() {
	m.timeout_time = nil
}

// SetBanDeleteMessageTime sets the "ban_delete_message_time" field.
func (m *ServerConfigMutation) SetBanDeleteMessageTime(sdmt serverconfig.BanDeleteMessageTime) {
	m.ban_delete_message_time = &sdmt
}

// BanDeleteMessageTime returns the value of the "ban_delete_message_time" field in the mutation.
func (m *ServerConfigMutation) BanDeleteMessageTime() (r serverconfig.BanDeleteMessageTime, exists bool) {
	v := m.ban_delete_message_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBanDeleteMessageTime returns the old "ban_delete_message_time" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldBanDeleteMessageTime(ctx context.Context) (v serverconfig.BanDeleteMessageTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBanDeleteMessageTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBanDeleteMessageTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBanDeleteMessageTime: %w", err)
	}
	return oldValue.BanDeleteMessageTime, nil
}

// ResetBanDeleteMessageTime resets all changes to the "ban_delete_message_time" field.
func (m *ServerConfigMutation) ResetBanDeleteMessageTime() {
	m.ban_delete_message_time = nil
}

// SetServerID sets the "server" edge to the Server entity by id.
func (m *ServerConfigMutation) SetServerID(id int) {
	m.server = &id
}

// ClearServer clears the "server" edge to the Server entity.
func (m *ServerConfigMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *ServerConfigMutation) ServerCleared() bool {
	return m.clearedserver
}

// ServerID returns the "server" edge ID in the mutation.
func (m *ServerConfigMutation) ServerID() (id int, exists bool) {
	if m.server != nil {
		return *m.server, true
	}
	return
}

// ServerIDs returns the "server" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerID instead. It exists only for internal usage by the builders.
func (m *ServerConfigMutation) ServerIDs() (ids []int) {
	if id := m.server; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *ServerConfigMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
}

// Where appends a list predicates to the ServerConfigMutation builder.
func (m *ServerConfigMutation) Where(ps ...predicate.ServerConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerConfig).
func (m *ServerConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerConfigMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.create_time != nil {
		fields = append(fields, serverconfig.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, serverconfig.FieldUpdateTime)
	}
	if m.remove_roles != nil {
		fields = append(fields, serverconfig.FieldRemoveRoles)
	}
	if m.give_role != nil {
		fields = append(fields, serverconfig.FieldGiveRole)
	}
	if m.timeout != nil {
		fields = append(fields, serverconfig.FieldTimeout)
	}
	if m.kick != nil {
		fields = append(fields, serverconfig.FieldKick)
	}
	if m.ban != nil {
		fields = append(fields, serverconfig.FieldBan)
	}
	if m.check_invites != nil {
		fields = append(fields, serverconfig.FieldCheckInvites)
	}
	if m.check_links != nil {
		fields = append(fields, serverconfig.FieldCheckLinks)
	}
	if m.ratelimit != nil {
		fields = append(fields, serverconfig.FieldRatelimit)
	}
	if m.alerts != nil {
		fields = append(fields, serverconfig.FieldAlerts)
	}
	if m.flag_links != nil {
		fields = append(fields, serverconfig.FieldFlagLinks)
	}
	if m.log_channel != nil {
		fields = append(fields, serverconfig.FieldLogChannel)
	}
	if m.given_role != nil {
		fields = append(fields, serverconfig.FieldGivenRole)
	}
	if m.excluded_channels != nil {
		fields = append(fields, serverconfig.FieldExcludedChannels)
	}
	if m.excluded_roles != nil {
		fields = append(fields, serverconfig.FieldExcludedRoles)
	}
	if m.excluded_users != nil {
		fields = append(fields, serverconfig.FieldExcludedUsers)
	}
	if m.ratelimit_message != nil {
		fields = append(fields, serverconfig.FieldRatelimitMessage)
	}
	if m.ratelimit_time != nil {
		fields = append(fields, serverconfig.FieldRatelimitTime)
	}
	if m.timeout_time != nil {
		fields = append(fields, serverconfig.FieldTimeoutTime)
	}
	if m.ban_delete_message_time != nil {
		fields = append(fields, serverconfig.FieldBanDeleteMessageTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serverconfig.FieldCreateTime:
		return m.CreateTime()
	case serverconfig.FieldUpdateTime:
		return m.UpdateTime()
	case serverconfig.FieldRemoveRoles:
		return m.RemoveRoles()
	case serverconfig.FieldGiveRole:
		return m.GiveRole()
	case serverconfig.FieldTimeout:
		return m.Timeout()
	case serverconfig.FieldKick:
		return m.Kick()
	case serverconfig.FieldBan:
		return m.Ban()
	case serverconfig.FieldCheckInvites:
		return m.CheckInvites()
	case serverconfig.FieldCheckLinks:
		return m.CheckLinks()
	case serverconfig.FieldRatelimit:
		return m.Ratelimit()
	case serverconfig.FieldAlerts:
		return m.Alerts()
	case serverconfig.FieldFlagLinks:
		return m.FlagLinks()
	case serverconfig.FieldLogChannel:
		return m.LogChannel()
	case serverconfig.FieldGivenRole:
		return m.GivenRole()
	case serverconfig.FieldExcludedChannels:
		return m.ExcludedChannels()
	case serverconfig.FieldExcludedRoles:
		return m.ExcludedRoles()
	case serverconfig.FieldExcludedUsers:
		return m.ExcludedUsers()
	case serverconfig.FieldRatelimitMessage:
		return m.RatelimitMessage()
	case serverconfig.FieldRatelimitTime:
		return m.RatelimitTime()
	case serverconfig.FieldTimeoutTime:
		return m.TimeoutTime()
	case serverconfig.FieldBanDeleteMessageTime:
		return m.BanDeleteMessageTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serverconfig.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case serverconfig.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case serverconfig.FieldRemoveRoles:
		return m.OldRemoveRoles(ctx)
	case serverconfig.FieldGiveRole:
		return m.OldGiveRole(ctx)
	case serverconfig.FieldTimeout:
		return m.OldTimeout(ctx)
	case serverconfig.FieldKick:
		return m.OldKick(ctx)
	case serverconfig.FieldBan:
		return m.OldBan(ctx)
	case serverconfig.FieldCheckInvites:
		return m.OldCheckInvites(ctx)
	case serverconfig.FieldCheckLinks:
		return m.OldCheckLinks(ctx)
	case serverconfig.FieldRatelimit:
		return m.OldRatelimit(ctx)
	case serverconfig.FieldAlerts:
		return m.OldAlerts(ctx)
	case serverconfig.FieldFlagLinks:
		return m.OldFlagLinks(ctx)
	case serverconfig.FieldLogChannel:
		return m.OldLogChannel(ctx)
	case serverconfig.FieldGivenRole:
		return m.OldGivenRole(ctx)
	case serverconfig.FieldExcludedChannels:
		return m.OldExcludedChannels(ctx)
	case serverconfig.FieldExcludedRoles:
		return m.OldExcludedRoles(ctx)
	case serverconfig.FieldExcludedUsers:
		return m.OldExcludedUsers(ctx)
	case serverconfig.FieldRatelimitMessage:
		return m.OldRatelimitMessage(ctx)
	case serverconfig.FieldRatelimitTime:
		return m.OldRatelimitTime(ctx)
	case serverconfig.FieldTimeoutTime:
		return m.OldTimeoutTime(ctx)
	case serverconfig.FieldBanDeleteMessageTime:
		return m.OldBanDeleteMessageTime(ctx)
	}
	return nil, fmt.Errorf("unknown ServerConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serverconfig.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case serverconfig.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case serverconfig.FieldRemoveRoles:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoveRoles(v)
		return nil
	case serverconfig.FieldGiveRole:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiveRole(v)
		return nil
	case serverconfig.FieldTimeout:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case serverconfig.FieldKick:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKick(v)
		return nil
	case serverconfig.FieldBan:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBan(v)
		return nil
	case serverconfig.FieldCheckInvites:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckInvites(v)
		return nil
	case serverconfig.FieldCheckLinks:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckLinks(v)
		return nil
	case serverconfig.FieldRatelimit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatelimit(v)
		return nil
	case serverconfig.FieldAlerts:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlerts(v)
		return nil
	case serverconfig.FieldFlagLinks:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlagLinks(v)
		return nil
	case serverconfig.FieldLogChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogChannel(v)
		return nil
	case serverconfig.FieldGivenRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGivenRole(v)
		return nil
	case serverconfig.FieldExcludedChannels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcludedChannels(v)
		return nil
	case serverconfig.FieldExcludedRoles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcludedRoles(v)
		return nil
	case serverconfig.FieldExcludedUsers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcludedUsers(v)
		return nil
	case serverconfig.FieldRatelimitMessage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatelimitMessage(v)
		return nil
	case serverconfig.FieldRatelimitTime:
		v, ok := value.(serverconfig.RatelimitTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatelimitTime(v)
		return nil
	case serverconfig.FieldTimeoutTime:
		v, ok := value.(serverconfig.TimeoutTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeoutTime(v)
		return nil
	case serverconfig.FieldBanDeleteMessageTime:
		v, ok := value.(serverconfig.BanDeleteMessageTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBanDeleteMessageTime(v)
		return nil
	}
	return fmt.Errorf("unknown ServerConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerConfigMutation) AddedFields() []string {
	var fields []string
	if m.addratelimit_message != nil {
		fields = append(fields, serverconfig.FieldRatelimitMessage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case serverconfig.FieldRatelimitMessage:
		return m.AddedRatelimitMessage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case serverconfig.FieldRatelimitMessage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatelimitMessage(v)
		return nil
	}
	return fmt.Errorf("unknown ServerConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerConfigMutation) ResetField(name string) error {
	switch name {
	case serverconfig.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case serverconfig.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case serverconfig.FieldRemoveRoles:
		m.ResetRemoveRoles()
		return nil
	case serverconfig.FieldGiveRole:
		m.ResetGiveRole()
		return nil
	case serverconfig.FieldTimeout:
		m.ResetTimeout()
		return nil
	case serverconfig.FieldKick:
		m.ResetKick()
		return nil
	case serverconfig.FieldBan:
		m.ResetBan()
		return nil
	case serverconfig.FieldCheckInvites:
		m.ResetCheckInvites()
		return nil
	case serverconfig.FieldCheckLinks:
		m.ResetCheckLinks()
		return nil
	case serverconfig.FieldRatelimit:
		m.ResetRatelimit()
		return nil
	case serverconfig.FieldAlerts:
		m.ResetAlerts()
		return nil
	case serverconfig.FieldFlagLinks:
		m.ResetFlagLinks()
		return nil
	case serverconfig.FieldLogChannel:
		m.ResetLogChannel()
		return nil
	case serverconfig.FieldGivenRole:
		m.ResetGivenRole()
		return nil
	case serverconfig.FieldExcludedChannels:
		m.ResetExcludedChannels()
		return nil
	case serverconfig.FieldExcludedRoles:
		m.ResetExcludedRoles()
		return nil
	case serverconfig.FieldExcludedUsers:
		m.ResetExcludedUsers()
		return nil
	case serverconfig.FieldRatelimitMessage:
		m.ResetRatelimitMessage()
		return nil
	case serverconfig.FieldRatelimitTime:
		m.ResetRatelimitTime()
		return nil
	case serverconfig.FieldTimeoutTime:
		m.ResetTimeoutTime()
		return nil
	case serverconfig.FieldBanDeleteMessageTime:
		m.ResetBanDeleteMessageTime()
		return nil
	}
	return fmt.Errorf("unknown ServerConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.server != nil {
		edges = append(edges, serverconfig.EdgeServer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serverconfig.EdgeServer:
		if id := m.server; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedserver {
		edges = append(edges, serverconfig.EdgeServer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case serverconfig.EdgeServer:
		return m.clearedserver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerConfigMutation) ClearEdge(name string) error {
	switch name {
	case serverconfig.EdgeServer:
		m.ClearServer()
		return nil
	}
	return fmt.Errorf("unknown ServerConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerConfigMutation) ResetEdge(name string) error {
	switch name {
	case serverconfig.EdgeServer:
		m.ResetServer()
		return nil
	}
	return fmt.Errorf("unknown ServerConfig edge %s", name)
}

// SpammerMutation represents an operation that mutates the Spammer nodes in the graph.
type SpammerMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	create_time         *time.Time
	update_time         *time.Time
	user_id             *string
	removed_roles       *[]string
	appendremoved_roles []string
	last_flagged        *time.Time
	clearedFields       map[string]struct{}
	server              *int
	clearedserver       bool
	done                bool
	oldValue            func(context.Context) (*Spammer, error)
	predicates          []predicate.Spammer
}

var _ ent.Mutation = (*SpammerMutation)(nil)

// spammerOption allows management of the mutation configuration using functional options.
type spammerOption func(*SpammerMutation)

// newSpammerMutation creates new mutation for the Spammer entity.
func newSpammerMutation(c config, op Op, opts ...spammerOption) *SpammerMutation {
	m := &SpammerMutation{
		config:        c,
		op:            op,
		typ:           TypeSpammer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpammerID sets the ID field of the mutation.
func withSpammerID(id int) spammerOption {
	return func(m *SpammerMutation) {
		var (
			err   error
			once  sync.Once
			value *Spammer
		)
		m.oldValue = func(ctx context.Context) (*Spammer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Spammer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpammer sets the old Spammer of the mutation.
func withSpammer(node *Spammer) spammerOption {
	return func(m *SpammerMutation) {
		m.oldValue = func(context.Context) (*Spammer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpammerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpammerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpammerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SpammerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Spammer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SpammerMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SpammerMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Spammer entity.
// If the Spammer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpammerMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SpammerMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SpammerMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SpammerMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Spammer entity.
// If the Spammer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpammerMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SpammerMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUserID sets the "user_id" field.
func (m *SpammerMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SpammerMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Spammer entity.
// If the Spammer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpammerMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SpammerMutation) ResetUserID() {
	m.user_id = nil
}

// SetRemovedRoles sets the "removed_roles" field.
func (m *SpammerMutation) SetRemovedRoles(s []string) {
	m.removed_roles = &s
	m.appendremoved_roles = nil
}

// RemovedRoles returns the value of the "removed_roles" field in the mutation.
func (m *SpammerMutation) RemovedRoles() (r []string, exists bool) {
	v := m.removed_roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRemovedRoles returns the old "removed_roles" field's value of the Spammer entity.
// If the Spammer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpammerMutation) OldRemovedRoles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemovedRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemovedRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemovedRoles: %w", err)
	}
	return oldValue.RemovedRoles, nil
}

// AppendRemovedRoles adds s to the "removed_roles" field.
func (m *SpammerMutation) AppendRemovedRoles(s []string) {
	m.appendremoved_roles = append(m.appendremoved_roles, s...)
}

// AppendedRemovedRoles returns the list of values that were appended to the "removed_roles" field in this mutation.
func (m *SpammerMutation) AppendedRemovedRoles() ([]string, bool) {
	if len(m.appendremoved_roles) == 0 {
		return nil, false
	}
	return m.appendremoved_roles, true
}

// ClearRemovedRoles clears the value of the "removed_roles" field.
func (m *SpammerMutation) ClearRemovedRoles() {
	m.removed_roles = nil
	m.appendremoved_roles = nil
	m.clearedFields[spammer.FieldRemovedRoles] = struct{}{}
}

// RemovedRolesCleared returns if the "removed_roles" field was cleared in this mutation.
func (m *SpammerMutation) RemovedRolesCleared() bool {
	_, ok := m.clearedFields[spammer.FieldRemovedRoles]
	return ok
}

// ResetRemovedRoles resets all changes to the "removed_roles" field.
func (m *SpammerMutation) ResetRemovedRoles() {
	m.removed_roles = nil
	m.appendremoved_roles = nil
	delete(m.clearedFields, spammer.FieldRemovedRoles)
}

// SetLastFlagged sets the "last_flagged" field.
func (m *SpammerMutation) SetLastFlagged(t time.Time) {
	m.last_flagged = &t
}

// LastFlagged returns the value of the "last_flagged" field in the mutation.
func (m *SpammerMutation) LastFlagged() (r time.Time, exists bool) {
	v := m.last_flagged
	if v == nil {
		return
	}
	return *v, true
}

// OldLastFlagged returns the old "last_flagged" field's value of the Spammer entity.
// If the Spammer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpammerMutation) OldLastFlagged(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastFlagged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastFlagged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastFlagged: %w", err)
	}
	return oldValue.LastFlagged, nil
}

// ResetLastFlagged resets all changes to the "last_flagged" field.
func (m *SpammerMutation) ResetLastFlagged() {
	m.last_flagged = nil
}

// SetServerID sets the "server" edge to the Server entity by id.
func (m *SpammerMutation) SetServerID(id int) {
	m.server = &id
}

// ClearServer clears the "server" edge to the Server entity.
func (m *SpammerMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *SpammerMutation) ServerCleared() bool {
	return m.clearedserver
}

// ServerID returns the "server" edge ID in the mutation.
func (m *SpammerMutation) ServerID() (id int, exists bool) {
	if m.server != nil {
		return *m.server, true
	}
	return
}

// ServerIDs returns the "server" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerID instead. It exists only for internal usage by the builders.
func (m *SpammerMutation) ServerIDs() (ids []int) {
	if id := m.server; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *SpammerMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
}

// Where appends a list predicates to the SpammerMutation builder.
func (m *SpammerMutation) Where(ps ...predicate.Spammer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SpammerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SpammerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Spammer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SpammerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SpammerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Spammer).
func (m *SpammerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpammerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, spammer.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, spammer.FieldUpdateTime)
	}
	if m.user_id != nil {
		fields = append(fields, spammer.FieldUserID)
	}
	if m.removed_roles != nil {
		fields = append(fields, spammer.FieldRemovedRoles)
	}
	if m.last_flagged != nil {
		fields = append(fields, spammer.FieldLastFlagged)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpammerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spammer.FieldCreateTime:
		return m.CreateTime()
	case spammer.FieldUpdateTime:
		return m.UpdateTime()
	case spammer.FieldUserID:
		return m.UserID()
	case spammer.FieldRemovedRoles:
		return m.RemovedRoles()
	case spammer.FieldLastFlagged:
		return m.LastFlagged()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpammerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spammer.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case spammer.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case spammer.FieldUserID:
		return m.OldUserID(ctx)
	case spammer.FieldRemovedRoles:
		return m.OldRemovedRoles(ctx)
	case spammer.FieldLastFlagged:
		return m.OldLastFlagged(ctx)
	}
	return nil, fmt.Errorf("unknown Spammer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpammerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spammer.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case spammer.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case spammer.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case spammer.FieldRemovedRoles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemovedRoles(v)
		return nil
	case spammer.FieldLastFlagged:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastFlagged(v)
		return nil
	}
	return fmt.Errorf("unknown Spammer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpammerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpammerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpammerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Spammer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpammerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(spammer.FieldRemovedRoles) {
		fields = append(fields, spammer.FieldRemovedRoles)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpammerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpammerMutation) ClearField(name string) error {
	switch name {
	case spammer.FieldRemovedRoles:
		m.ClearRemovedRoles()
		return nil
	}
	return fmt.Errorf("unknown Spammer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpammerMutation) ResetField(name string) error {
	switch name {
	case spammer.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case spammer.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case spammer.FieldUserID:
		m.ResetUserID()
		return nil
	case spammer.FieldRemovedRoles:
		m.ResetRemovedRoles()
		return nil
	case spammer.FieldLastFlagged:
		m.ResetLastFlagged()
		return nil
	}
	return fmt.Errorf("unknown Spammer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpammerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.server != nil {
		edges = append(edges, spammer.EdgeServer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpammerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spammer.EdgeServer:
		if id := m.server; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpammerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpammerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpammerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedserver {
		edges = append(edges, spammer.EdgeServer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpammerMutation) EdgeCleared(name string) bool {
	switch name {
	case spammer.EdgeServer:
		return m.clearedserver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpammerMutation) ClearEdge(name string) error {
	switch name {
	case spammer.EdgeServer:
		m.ClearServer()
		return nil
	}
	return fmt.Errorf("unknown Spammer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpammerMutation) ResetEdge(name string) error {
	switch name {
	case spammer.EdgeServer:
		m.ResetServer()
		return nil
	}
	return fmt.Errorf("unknown Spammer edge %s", name)
}

// WordBlacklistMutation represents an operation that mutates the WordBlacklist nodes in the graph.
type WordBlacklistMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	word          *string
	clearedFields map[string]struct{}
	server        map[int]struct{}
	removedserver map[int]struct{}
	clearedserver bool
	done          bool
	oldValue      func(context.Context) (*WordBlacklist, error)
	predicates    []predicate.WordBlacklist
}

var _ ent.Mutation = (*WordBlacklistMutation)(nil)

// wordblacklistOption allows management of the mutation configuration using functional options.
type wordblacklistOption func(*WordBlacklistMutation)

// newWordBlacklistMutation creates new mutation for the WordBlacklist entity.
func newWordBlacklistMutation(c config, op Op, opts ...wordblacklistOption) *WordBlacklistMutation {
	m := &WordBlacklistMutation{
		config:        c,
		op:            op,
		typ:           TypeWordBlacklist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWordBlacklistID sets the ID field of the mutation.
func withWordBlacklistID(id int) wordblacklistOption {
	return func(m *WordBlacklistMutation) {
		var (
			err   error
			once  sync.Once
			value *WordBlacklist
		)
		m.oldValue = func(ctx context.Context) (*WordBlacklist, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WordBlacklist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWordBlacklist sets the old WordBlacklist of the mutation.
func withWordBlacklist(node *WordBlacklist) wordblacklistOption {
	return func(m *WordBlacklistMutation) {
		m.oldValue = func(context.Context) (*WordBlacklist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WordBlacklistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WordBlacklistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WordBlacklistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WordBlacklistMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WordBlacklist.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *WordBlacklistMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WordBlacklistMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WordBlacklist entity.
// If the WordBlacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordBlacklistMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WordBlacklistMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WordBlacklistMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WordBlacklistMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WordBlacklist entity.
// If the WordBlacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordBlacklistMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WordBlacklistMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetWord sets the "word" field.
func (m *WordBlacklistMutation) SetWord(s string) {
	m.word = &s
}

// Word returns the value of the "word" field in the mutation.
func (m *WordBlacklistMutation) Word() (r string, exists bool) {
	v := m.word
	if v == nil {
		return
	}
	return *v, true
}

// OldWord returns the old "word" field's value of the WordBlacklist entity.
// If the WordBlacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordBlacklistMutation) OldWord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWord: %w", err)
	}
	return oldValue.Word, nil
}

// ResetWord resets all changes to the "word" field.
func (m *WordBlacklistMutation) ResetWord() {
	m.word = nil
}

// AddServerIDs adds the "server" edge to the Server entity by ids.
func (m *WordBlacklistMutation) AddServerIDs(ids ...int) {
	if m.server == nil {
		m.server = make(map[int]struct{})
	}
	for i := range ids {
		m.server[ids[i]] = struct{}{}
	}
}

// ClearServer clears the "server" edge to the Server entity.
func (m *WordBlacklistMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *WordBlacklistMutation) ServerCleared() bool {
	return m.clearedserver
}

// RemoveServerIDs removes the "server" edge to the Server entity by IDs.
func (m *WordBlacklistMutation) RemoveServerIDs(ids ...int) {
	if m.removedserver == nil {
		m.removedserver = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.server, ids[i])
		m.removedserver[ids[i]] = struct{}{}
	}
}

// RemovedServer returns the removed IDs of the "server" edge to the Server entity.
func (m *WordBlacklistMutation) RemovedServerIDs() (ids []int) {
	for id := range m.removedserver {
		ids = append(ids, id)
	}
	return
}

// ServerIDs returns the "server" edge IDs in the mutation.
func (m *WordBlacklistMutation) ServerIDs() (ids []int) {
	for id := range m.server {
		ids = append(ids, id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *WordBlacklistMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
	m.removedserver = nil
}

// Where appends a list predicates to the WordBlacklistMutation builder.
func (m *WordBlacklistMutation) Where(ps ...predicate.WordBlacklist) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WordBlacklistMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WordBlacklistMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WordBlacklist, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WordBlacklistMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WordBlacklistMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WordBlacklist).
func (m *WordBlacklistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WordBlacklistMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, wordblacklist.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, wordblacklist.FieldUpdateTime)
	}
	if m.word != nil {
		fields = append(fields, wordblacklist.FieldWord)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WordBlacklistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wordblacklist.FieldCreateTime:
		return m.CreateTime()
	case wordblacklist.FieldUpdateTime:
		return m.UpdateTime()
	case wordblacklist.FieldWord:
		return m.Word()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WordBlacklistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wordblacklist.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case wordblacklist.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case wordblacklist.FieldWord:
		return m.OldWord(ctx)
	}
	return nil, fmt.Errorf("unknown WordBlacklist field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WordBlacklistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wordblacklist.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case wordblacklist.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case wordblacklist.FieldWord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWord(v)
		return nil
	}
	return fmt.Errorf("unknown WordBlacklist field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WordBlacklistMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WordBlacklistMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WordBlacklistMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WordBlacklist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WordBlacklistMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WordBlacklistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WordBlacklistMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WordBlacklist nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WordBlacklistMutation) ResetField(name string) error {
	switch name {
	case wordblacklist.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case wordblacklist.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case wordblacklist.FieldWord:
		m.ResetWord()
		return nil
	}
	return fmt.Errorf("unknown WordBlacklist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WordBlacklistMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.server != nil {
		edges = append(edges, wordblacklist.EdgeServer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WordBlacklistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wordblacklist.EdgeServer:
		ids := make([]ent.Value, 0, len(m.server))
		for id := range m.server {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WordBlacklistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedserver != nil {
		edges = append(edges, wordblacklist.EdgeServer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WordBlacklistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case wordblacklist.EdgeServer:
		ids := make([]ent.Value, 0, len(m.removedserver))
		for id := range m.removedserver {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WordBlacklistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedserver {
		edges = append(edges, wordblacklist.EdgeServer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WordBlacklistMutation) EdgeCleared(name string) bool {
	switch name {
	case wordblacklist.EdgeServer:
		return m.clearedserver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WordBlacklistMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown WordBlacklist unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WordBlacklistMutation) ResetEdge(name string) error {
	switch name {
	case wordblacklist.EdgeServer:
		m.ResetServer()
		return nil
	}
	return fmt.Errorf("unknown WordBlacklist edge %s", name)
}
