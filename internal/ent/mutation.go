// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/FM1337/ASB/internal/ent/predicate"
	"github.com/FM1337/ASB/internal/ent/server"
	"github.com/FM1337/ASB/internal/ent/serverconfig"
	"github.com/FM1337/ASB/internal/ent/wordblacklist"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeServer        = "Server"
	TypeServerConfig  = "ServerConfig"
	TypeWordBlacklist = "WordBlacklist"
)

// ServerMutation represents an operation that mutates the Server nodes in the graph.
type ServerMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	create_time           *time.Time
	update_time           *time.Time
	owner_id              *string
	enabled               *bool
	clearedFields         map[string]struct{}
	configuration         *int
	clearedconfiguration  bool
	word_blacklist        map[int]struct{}
	removedword_blacklist map[int]struct{}
	clearedword_blacklist bool
	done                  bool
	oldValue              func(context.Context) (*Server, error)
	predicates            []predicate.Server
}

var _ ent.Mutation = (*ServerMutation)(nil)

// serverOption allows management of the mutation configuration using functional options.
type serverOption func(*ServerMutation)

// newServerMutation creates new mutation for the Server entity.
func newServerMutation(c config, op Op, opts ...serverOption) *ServerMutation {
	m := &ServerMutation{
		config:        c,
		op:            op,
		typ:           TypeServer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerID sets the ID field of the mutation.
func withServerID(id string) serverOption {
	return func(m *ServerMutation) {
		var (
			err   error
			once  sync.Once
			value *Server
		)
		m.oldValue = func(ctx context.Context) (*Server, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Server.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServer sets the old Server of the mutation.
func withServer(node *Server) serverOption {
	return func(m *ServerMutation) {
		m.oldValue = func(context.Context) (*Server, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Server entities.
func (m *ServerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Server.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServerMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServerMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServerMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ServerMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ServerMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ServerMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *ServerMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ServerMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ServerMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetEnabled sets the "enabled" field.
func (m *ServerMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ServerMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ServerMutation) ResetEnabled() {
	m.enabled = nil
}

// SetConfigurationID sets the "configuration" edge to the ServerConfig entity by id.
func (m *ServerMutation) SetConfigurationID(id int) {
	m.configuration = &id
}

// ClearConfiguration clears the "configuration" edge to the ServerConfig entity.
func (m *ServerMutation) ClearConfiguration() {
	m.clearedconfiguration = true
}

// ConfigurationCleared reports if the "configuration" edge to the ServerConfig entity was cleared.
func (m *ServerMutation) ConfigurationCleared() bool {
	return m.clearedconfiguration
}

// ConfigurationID returns the "configuration" edge ID in the mutation.
func (m *ServerMutation) ConfigurationID() (id int, exists bool) {
	if m.configuration != nil {
		return *m.configuration, true
	}
	return
}

// ConfigurationIDs returns the "configuration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConfigurationID instead. It exists only for internal usage by the builders.
func (m *ServerMutation) ConfigurationIDs() (ids []int) {
	if id := m.configuration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfiguration resets all changes to the "configuration" edge.
func (m *ServerMutation) ResetConfiguration() {
	m.configuration = nil
	m.clearedconfiguration = false
}

// AddWordBlacklistIDs adds the "word_blacklist" edge to the WordBlacklist entity by ids.
func (m *ServerMutation) AddWordBlacklistIDs(ids ...int) {
	if m.word_blacklist == nil {
		m.word_blacklist = make(map[int]struct{})
	}
	for i := range ids {
		m.word_blacklist[ids[i]] = struct{}{}
	}
}

// ClearWordBlacklist clears the "word_blacklist" edge to the WordBlacklist entity.
func (m *ServerMutation) ClearWordBlacklist() {
	m.clearedword_blacklist = true
}

// WordBlacklistCleared reports if the "word_blacklist" edge to the WordBlacklist entity was cleared.
func (m *ServerMutation) WordBlacklistCleared() bool {
	return m.clearedword_blacklist
}

// RemoveWordBlacklistIDs removes the "word_blacklist" edge to the WordBlacklist entity by IDs.
func (m *ServerMutation) RemoveWordBlacklistIDs(ids ...int) {
	if m.removedword_blacklist == nil {
		m.removedword_blacklist = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.word_blacklist, ids[i])
		m.removedword_blacklist[ids[i]] = struct{}{}
	}
}

// RemovedWordBlacklist returns the removed IDs of the "word_blacklist" edge to the WordBlacklist entity.
func (m *ServerMutation) RemovedWordBlacklistIDs() (ids []int) {
	for id := range m.removedword_blacklist {
		ids = append(ids, id)
	}
	return
}

// WordBlacklistIDs returns the "word_blacklist" edge IDs in the mutation.
func (m *ServerMutation) WordBlacklistIDs() (ids []int) {
	for id := range m.word_blacklist {
		ids = append(ids, id)
	}
	return
}

// ResetWordBlacklist resets all changes to the "word_blacklist" edge.
func (m *ServerMutation) ResetWordBlacklist() {
	m.word_blacklist = nil
	m.clearedword_blacklist = false
	m.removedword_blacklist = nil
}

// Where appends a list predicates to the ServerMutation builder.
func (m *ServerMutation) Where(ps ...predicate.Server) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Server, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Server).
func (m *ServerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, server.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, server.FieldUpdateTime)
	}
	if m.owner_id != nil {
		fields = append(fields, server.FieldOwnerID)
	}
	if m.enabled != nil {
		fields = append(fields, server.FieldEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case server.FieldCreateTime:
		return m.CreateTime()
	case server.FieldUpdateTime:
		return m.UpdateTime()
	case server.FieldOwnerID:
		return m.OwnerID()
	case server.FieldEnabled:
		return m.Enabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case server.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case server.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case server.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case server.FieldEnabled:
		return m.OldEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown Server field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case server.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case server.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case server.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case server.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Server numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Server nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerMutation) ResetField(name string) error {
	switch name {
	case server.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case server.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case server.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case server.FieldEnabled:
		m.ResetEnabled()
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.configuration != nil {
		edges = append(edges, server.EdgeConfiguration)
	}
	if m.word_blacklist != nil {
		edges = append(edges, server.EdgeWordBlacklist)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case server.EdgeConfiguration:
		if id := m.configuration; id != nil {
			return []ent.Value{*id}
		}
	case server.EdgeWordBlacklist:
		ids := make([]ent.Value, 0, len(m.word_blacklist))
		for id := range m.word_blacklist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedword_blacklist != nil {
		edges = append(edges, server.EdgeWordBlacklist)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case server.EdgeWordBlacklist:
		ids := make([]ent.Value, 0, len(m.removedword_blacklist))
		for id := range m.removedword_blacklist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedconfiguration {
		edges = append(edges, server.EdgeConfiguration)
	}
	if m.clearedword_blacklist {
		edges = append(edges, server.EdgeWordBlacklist)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerMutation) EdgeCleared(name string) bool {
	switch name {
	case server.EdgeConfiguration:
		return m.clearedconfiguration
	case server.EdgeWordBlacklist:
		return m.clearedword_blacklist
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerMutation) ClearEdge(name string) error {
	switch name {
	case server.EdgeConfiguration:
		m.ClearConfiguration()
		return nil
	}
	return fmt.Errorf("unknown Server unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerMutation) ResetEdge(name string) error {
	switch name {
	case server.EdgeConfiguration:
		m.ResetConfiguration()
		return nil
	case server.EdgeWordBlacklist:
		m.ResetWordBlacklist()
		return nil
	}
	return fmt.Errorf("unknown Server edge %s", name)
}

// ServerConfigMutation represents an operation that mutates the ServerConfig nodes in the graph.
type ServerConfigMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	remove_roles            *bool
	give_role               *bool
	timeout                 *bool
	kick                    *bool
	ban                     *bool
	check_invites           *bool
	check_links             *bool
	ratelimit               *bool
	alerts                  *bool
	flag_links              *bool
	log_channel             *string
	excluded_channels       *[]string
	appendexcluded_channels []string
	excluded_roles          *[]string
	appendexcluded_roles    []string
	excluded_users          *[]string
	appendexcluded_users    []string
	given_role              *string
	ratelimit_message       *int
	addratelimit_message    *int
	ratelimit_time          *serverconfig.RatelimitTime
	timeout_time            *serverconfig.TimeoutTime
	ban_delete_message_time *serverconfig.BanDeleteMessageTime
	clearedFields           map[string]struct{}
	server                  map[string]struct{}
	removedserver           map[string]struct{}
	clearedserver           bool
	done                    bool
	oldValue                func(context.Context) (*ServerConfig, error)
	predicates              []predicate.ServerConfig
}

var _ ent.Mutation = (*ServerConfigMutation)(nil)

// serverconfigOption allows management of the mutation configuration using functional options.
type serverconfigOption func(*ServerConfigMutation)

// newServerConfigMutation creates new mutation for the ServerConfig entity.
func newServerConfigMutation(c config, op Op, opts ...serverconfigOption) *ServerConfigMutation {
	m := &ServerConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeServerConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerConfigID sets the ID field of the mutation.
func withServerConfigID(id int) serverconfigOption {
	return func(m *ServerConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerConfig
		)
		m.oldValue = func(ctx context.Context) (*ServerConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerConfig sets the old ServerConfig of the mutation.
func withServerConfig(node *ServerConfig) serverconfigOption {
	return func(m *ServerConfigMutation) {
		m.oldValue = func(context.Context) (*ServerConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServerConfigMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServerConfigMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServerConfigMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ServerConfigMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ServerConfigMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ServerConfigMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetRemoveRoles sets the "remove_roles" field.
func (m *ServerConfigMutation) SetRemoveRoles(b bool) {
	m.remove_roles = &b
}

// RemoveRoles returns the value of the "remove_roles" field in the mutation.
func (m *ServerConfigMutation) RemoveRoles() (r bool, exists bool) {
	v := m.remove_roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoveRoles returns the old "remove_roles" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldRemoveRoles(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoveRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoveRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoveRoles: %w", err)
	}
	return oldValue.RemoveRoles, nil
}

// ResetRemoveRoles resets all changes to the "remove_roles" field.
func (m *ServerConfigMutation) ResetRemoveRoles() {
	m.remove_roles = nil
}

// SetGiveRole sets the "give_role" field.
func (m *ServerConfigMutation) SetGiveRole(b bool) {
	m.give_role = &b
}

// GiveRole returns the value of the "give_role" field in the mutation.
func (m *ServerConfigMutation) GiveRole() (r bool, exists bool) {
	v := m.give_role
	if v == nil {
		return
	}
	return *v, true
}

// OldGiveRole returns the old "give_role" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldGiveRole(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiveRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiveRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiveRole: %w", err)
	}
	return oldValue.GiveRole, nil
}

// ResetGiveRole resets all changes to the "give_role" field.
func (m *ServerConfigMutation) ResetGiveRole() {
	m.give_role = nil
}

// SetTimeout sets the "timeout" field.
func (m *ServerConfigMutation) SetTimeout(b bool) {
	m.timeout = &b
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *ServerConfigMutation) Timeout() (r bool, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldTimeout(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *ServerConfigMutation) ResetTimeout() {
	m.timeout = nil
}

// SetKick sets the "kick" field.
func (m *ServerConfigMutation) SetKick(b bool) {
	m.kick = &b
}

// Kick returns the value of the "kick" field in the mutation.
func (m *ServerConfigMutation) Kick() (r bool, exists bool) {
	v := m.kick
	if v == nil {
		return
	}
	return *v, true
}

// OldKick returns the old "kick" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldKick(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKick is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKick requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKick: %w", err)
	}
	return oldValue.Kick, nil
}

// ResetKick resets all changes to the "kick" field.
func (m *ServerConfigMutation) ResetKick() {
	m.kick = nil
}

// SetBan sets the "ban" field.
func (m *ServerConfigMutation) SetBan(b bool) {
	m.ban = &b
}

// Ban returns the value of the "ban" field in the mutation.
func (m *ServerConfigMutation) Ban() (r bool, exists bool) {
	v := m.ban
	if v == nil {
		return
	}
	return *v, true
}

// OldBan returns the old "ban" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldBan(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBan: %w", err)
	}
	return oldValue.Ban, nil
}

// ResetBan resets all changes to the "ban" field.
func (m *ServerConfigMutation) ResetBan() {
	m.ban = nil
}

// SetCheckInvites sets the "check_invites" field.
func (m *ServerConfigMutation) SetCheckInvites(b bool) {
	m.check_invites = &b
}

// CheckInvites returns the value of the "check_invites" field in the mutation.
func (m *ServerConfigMutation) CheckInvites() (r bool, exists bool) {
	v := m.check_invites
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckInvites returns the old "check_invites" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldCheckInvites(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckInvites is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckInvites requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckInvites: %w", err)
	}
	return oldValue.CheckInvites, nil
}

// ResetCheckInvites resets all changes to the "check_invites" field.
func (m *ServerConfigMutation) ResetCheckInvites() {
	m.check_invites = nil
}

// SetCheckLinks sets the "check_links" field.
func (m *ServerConfigMutation) SetCheckLinks(b bool) {
	m.check_links = &b
}

// CheckLinks returns the value of the "check_links" field in the mutation.
func (m *ServerConfigMutation) CheckLinks() (r bool, exists bool) {
	v := m.check_links
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckLinks returns the old "check_links" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldCheckLinks(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckLinks: %w", err)
	}
	return oldValue.CheckLinks, nil
}

// ResetCheckLinks resets all changes to the "check_links" field.
func (m *ServerConfigMutation) ResetCheckLinks() {
	m.check_links = nil
}

// SetRatelimit sets the "ratelimit" field.
func (m *ServerConfigMutation) SetRatelimit(b bool) {
	m.ratelimit = &b
}

// Ratelimit returns the value of the "ratelimit" field in the mutation.
func (m *ServerConfigMutation) Ratelimit() (r bool, exists bool) {
	v := m.ratelimit
	if v == nil {
		return
	}
	return *v, true
}

// OldRatelimit returns the old "ratelimit" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldRatelimit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatelimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatelimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatelimit: %w", err)
	}
	return oldValue.Ratelimit, nil
}

// ResetRatelimit resets all changes to the "ratelimit" field.
func (m *ServerConfigMutation) ResetRatelimit() {
	m.ratelimit = nil
}

// SetAlerts sets the "alerts" field.
func (m *ServerConfigMutation) SetAlerts(b bool) {
	m.alerts = &b
}

// Alerts returns the value of the "alerts" field in the mutation.
func (m *ServerConfigMutation) Alerts() (r bool, exists bool) {
	v := m.alerts
	if v == nil {
		return
	}
	return *v, true
}

// OldAlerts returns the old "alerts" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldAlerts(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlerts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlerts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlerts: %w", err)
	}
	return oldValue.Alerts, nil
}

// ResetAlerts resets all changes to the "alerts" field.
func (m *ServerConfigMutation) ResetAlerts() {
	m.alerts = nil
}

// SetFlagLinks sets the "flag_links" field.
func (m *ServerConfigMutation) SetFlagLinks(b bool) {
	m.flag_links = &b
}

// FlagLinks returns the value of the "flag_links" field in the mutation.
func (m *ServerConfigMutation) FlagLinks() (r bool, exists bool) {
	v := m.flag_links
	if v == nil {
		return
	}
	return *v, true
}

// OldFlagLinks returns the old "flag_links" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldFlagLinks(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlagLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlagLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlagLinks: %w", err)
	}
	return oldValue.FlagLinks, nil
}

// ResetFlagLinks resets all changes to the "flag_links" field.
func (m *ServerConfigMutation) ResetFlagLinks() {
	m.flag_links = nil
}

// SetLogChannel sets the "log_channel" field.
func (m *ServerConfigMutation) SetLogChannel(s string) {
	m.log_channel = &s
}

// LogChannel returns the value of the "log_channel" field in the mutation.
func (m *ServerConfigMutation) LogChannel() (r string, exists bool) {
	v := m.log_channel
	if v == nil {
		return
	}
	return *v, true
}

// OldLogChannel returns the old "log_channel" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldLogChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogChannel: %w", err)
	}
	return oldValue.LogChannel, nil
}

// ResetLogChannel resets all changes to the "log_channel" field.
func (m *ServerConfigMutation) ResetLogChannel() {
	m.log_channel = nil
}

// SetExcludedChannels sets the "excluded_channels" field.
func (m *ServerConfigMutation) SetExcludedChannels(s []string) {
	m.excluded_channels = &s
	m.appendexcluded_channels = nil
}

// ExcludedChannels returns the value of the "excluded_channels" field in the mutation.
func (m *ServerConfigMutation) ExcludedChannels() (r []string, exists bool) {
	v := m.excluded_channels
	if v == nil {
		return
	}
	return *v, true
}

// OldExcludedChannels returns the old "excluded_channels" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldExcludedChannels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcludedChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcludedChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcludedChannels: %w", err)
	}
	return oldValue.ExcludedChannels, nil
}

// AppendExcludedChannels adds s to the "excluded_channels" field.
func (m *ServerConfigMutation) AppendExcludedChannels(s []string) {
	m.appendexcluded_channels = append(m.appendexcluded_channels, s...)
}

// AppendedExcludedChannels returns the list of values that were appended to the "excluded_channels" field in this mutation.
func (m *ServerConfigMutation) AppendedExcludedChannels() ([]string, bool) {
	if len(m.appendexcluded_channels) == 0 {
		return nil, false
	}
	return m.appendexcluded_channels, true
}

// ResetExcludedChannels resets all changes to the "excluded_channels" field.
func (m *ServerConfigMutation) ResetExcludedChannels() {
	m.excluded_channels = nil
	m.appendexcluded_channels = nil
}

// SetExcludedRoles sets the "excluded_roles" field.
func (m *ServerConfigMutation) SetExcludedRoles(s []string) {
	m.excluded_roles = &s
	m.appendexcluded_roles = nil
}

// ExcludedRoles returns the value of the "excluded_roles" field in the mutation.
func (m *ServerConfigMutation) ExcludedRoles() (r []string, exists bool) {
	v := m.excluded_roles
	if v == nil {
		return
	}
	return *v, true
}

// OldExcludedRoles returns the old "excluded_roles" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldExcludedRoles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcludedRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcludedRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcludedRoles: %w", err)
	}
	return oldValue.ExcludedRoles, nil
}

// AppendExcludedRoles adds s to the "excluded_roles" field.
func (m *ServerConfigMutation) AppendExcludedRoles(s []string) {
	m.appendexcluded_roles = append(m.appendexcluded_roles, s...)
}

// AppendedExcludedRoles returns the list of values that were appended to the "excluded_roles" field in this mutation.
func (m *ServerConfigMutation) AppendedExcludedRoles() ([]string, bool) {
	if len(m.appendexcluded_roles) == 0 {
		return nil, false
	}
	return m.appendexcluded_roles, true
}

// ResetExcludedRoles resets all changes to the "excluded_roles" field.
func (m *ServerConfigMutation) ResetExcludedRoles() {
	m.excluded_roles = nil
	m.appendexcluded_roles = nil
}

// SetExcludedUsers sets the "excluded_users" field.
func (m *ServerConfigMutation) SetExcludedUsers(s []string) {
	m.excluded_users = &s
	m.appendexcluded_users = nil
}

// ExcludedUsers returns the value of the "excluded_users" field in the mutation.
func (m *ServerConfigMutation) ExcludedUsers() (r []string, exists bool) {
	v := m.excluded_users
	if v == nil {
		return
	}
	return *v, true
}

// OldExcludedUsers returns the old "excluded_users" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldExcludedUsers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcludedUsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcludedUsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcludedUsers: %w", err)
	}
	return oldValue.ExcludedUsers, nil
}

// AppendExcludedUsers adds s to the "excluded_users" field.
func (m *ServerConfigMutation) AppendExcludedUsers(s []string) {
	m.appendexcluded_users = append(m.appendexcluded_users, s...)
}

// AppendedExcludedUsers returns the list of values that were appended to the "excluded_users" field in this mutation.
func (m *ServerConfigMutation) AppendedExcludedUsers() ([]string, bool) {
	if len(m.appendexcluded_users) == 0 {
		return nil, false
	}
	return m.appendexcluded_users, true
}

// ResetExcludedUsers resets all changes to the "excluded_users" field.
func (m *ServerConfigMutation) ResetExcludedUsers() {
	m.excluded_users = nil
	m.appendexcluded_users = nil
}

// SetGivenRole sets the "given_role" field.
func (m *ServerConfigMutation) SetGivenRole(s string) {
	m.given_role = &s
}

// GivenRole returns the value of the "given_role" field in the mutation.
func (m *ServerConfigMutation) GivenRole() (r string, exists bool) {
	v := m.given_role
	if v == nil {
		return
	}
	return *v, true
}

// OldGivenRole returns the old "given_role" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldGivenRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGivenRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGivenRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGivenRole: %w", err)
	}
	return oldValue.GivenRole, nil
}

// ResetGivenRole resets all changes to the "given_role" field.
func (m *ServerConfigMutation) ResetGivenRole() {
	m.given_role = nil
}

// SetRatelimitMessage sets the "ratelimit_message" field.
func (m *ServerConfigMutation) SetRatelimitMessage(i int) {
	m.ratelimit_message = &i
	m.addratelimit_message = nil
}

// RatelimitMessage returns the value of the "ratelimit_message" field in the mutation.
func (m *ServerConfigMutation) RatelimitMessage() (r int, exists bool) {
	v := m.ratelimit_message
	if v == nil {
		return
	}
	return *v, true
}

// OldRatelimitMessage returns the old "ratelimit_message" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldRatelimitMessage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatelimitMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatelimitMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatelimitMessage: %w", err)
	}
	return oldValue.RatelimitMessage, nil
}

// AddRatelimitMessage adds i to the "ratelimit_message" field.
func (m *ServerConfigMutation) AddRatelimitMessage(i int) {
	if m.addratelimit_message != nil {
		*m.addratelimit_message += i
	} else {
		m.addratelimit_message = &i
	}
}

// AddedRatelimitMessage returns the value that was added to the "ratelimit_message" field in this mutation.
func (m *ServerConfigMutation) AddedRatelimitMessage() (r int, exists bool) {
	v := m.addratelimit_message
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatelimitMessage resets all changes to the "ratelimit_message" field.
func (m *ServerConfigMutation) ResetRatelimitMessage() {
	m.ratelimit_message = nil
	m.addratelimit_message = nil
}

// SetRatelimitTime sets the "ratelimit_time" field.
func (m *ServerConfigMutation) SetRatelimitTime(st serverconfig.RatelimitTime) {
	m.ratelimit_time = &st
}

// RatelimitTime returns the value of the "ratelimit_time" field in the mutation.
func (m *ServerConfigMutation) RatelimitTime() (r serverconfig.RatelimitTime, exists bool) {
	v := m.ratelimit_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRatelimitTime returns the old "ratelimit_time" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldRatelimitTime(ctx context.Context) (v serverconfig.RatelimitTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatelimitTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatelimitTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatelimitTime: %w", err)
	}
	return oldValue.RatelimitTime, nil
}

// ResetRatelimitTime resets all changes to the "ratelimit_time" field.
func (m *ServerConfigMutation) ResetRatelimitTime() {
	m.ratelimit_time = nil
}

// SetTimeoutTime sets the "timeout_time" field.
func (m *ServerConfigMutation) SetTimeoutTime(st serverconfig.TimeoutTime) {
	m.timeout_time = &st
}

// TimeoutTime returns the value of the "timeout_time" field in the mutation.
func (m *ServerConfigMutation) TimeoutTime() (r serverconfig.TimeoutTime, exists bool) {
	v := m.timeout_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeoutTime returns the old "timeout_time" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldTimeoutTime(ctx context.Context) (v serverconfig.TimeoutTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeoutTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeoutTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeoutTime: %w", err)
	}
	return oldValue.TimeoutTime, nil
}

// ResetTimeoutTime resets all changes to the "timeout_time" field.
func (m *ServerConfigMutation) ResetTimeoutTime() {
	m.timeout_time = nil
}

// SetBanDeleteMessageTime sets the "ban_delete_message_time" field.
func (m *ServerConfigMutation) SetBanDeleteMessageTime(sdmt serverconfig.BanDeleteMessageTime) {
	m.ban_delete_message_time = &sdmt
}

// BanDeleteMessageTime returns the value of the "ban_delete_message_time" field in the mutation.
func (m *ServerConfigMutation) BanDeleteMessageTime() (r serverconfig.BanDeleteMessageTime, exists bool) {
	v := m.ban_delete_message_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBanDeleteMessageTime returns the old "ban_delete_message_time" field's value of the ServerConfig entity.
// If the ServerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerConfigMutation) OldBanDeleteMessageTime(ctx context.Context) (v serverconfig.BanDeleteMessageTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBanDeleteMessageTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBanDeleteMessageTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBanDeleteMessageTime: %w", err)
	}
	return oldValue.BanDeleteMessageTime, nil
}

// ResetBanDeleteMessageTime resets all changes to the "ban_delete_message_time" field.
func (m *ServerConfigMutation) ResetBanDeleteMessageTime() {
	m.ban_delete_message_time = nil
}

// AddServerIDs adds the "server" edge to the Server entity by ids.
func (m *ServerConfigMutation) AddServerIDs(ids ...string) {
	if m.server == nil {
		m.server = make(map[string]struct{})
	}
	for i := range ids {
		m.server[ids[i]] = struct{}{}
	}
}

// ClearServer clears the "server" edge to the Server entity.
func (m *ServerConfigMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *ServerConfigMutation) ServerCleared() bool {
	return m.clearedserver
}

// RemoveServerIDs removes the "server" edge to the Server entity by IDs.
func (m *ServerConfigMutation) RemoveServerIDs(ids ...string) {
	if m.removedserver == nil {
		m.removedserver = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.server, ids[i])
		m.removedserver[ids[i]] = struct{}{}
	}
}

// RemovedServer returns the removed IDs of the "server" edge to the Server entity.
func (m *ServerConfigMutation) RemovedServerIDs() (ids []string) {
	for id := range m.removedserver {
		ids = append(ids, id)
	}
	return
}

// ServerIDs returns the "server" edge IDs in the mutation.
func (m *ServerConfigMutation) ServerIDs() (ids []string) {
	for id := range m.server {
		ids = append(ids, id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *ServerConfigMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
	m.removedserver = nil
}

// Where appends a list predicates to the ServerConfigMutation builder.
func (m *ServerConfigMutation) Where(ps ...predicate.ServerConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerConfig).
func (m *ServerConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerConfigMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.create_time != nil {
		fields = append(fields, serverconfig.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, serverconfig.FieldUpdateTime)
	}
	if m.remove_roles != nil {
		fields = append(fields, serverconfig.FieldRemoveRoles)
	}
	if m.give_role != nil {
		fields = append(fields, serverconfig.FieldGiveRole)
	}
	if m.timeout != nil {
		fields = append(fields, serverconfig.FieldTimeout)
	}
	if m.kick != nil {
		fields = append(fields, serverconfig.FieldKick)
	}
	if m.ban != nil {
		fields = append(fields, serverconfig.FieldBan)
	}
	if m.check_invites != nil {
		fields = append(fields, serverconfig.FieldCheckInvites)
	}
	if m.check_links != nil {
		fields = append(fields, serverconfig.FieldCheckLinks)
	}
	if m.ratelimit != nil {
		fields = append(fields, serverconfig.FieldRatelimit)
	}
	if m.alerts != nil {
		fields = append(fields, serverconfig.FieldAlerts)
	}
	if m.flag_links != nil {
		fields = append(fields, serverconfig.FieldFlagLinks)
	}
	if m.log_channel != nil {
		fields = append(fields, serverconfig.FieldLogChannel)
	}
	if m.excluded_channels != nil {
		fields = append(fields, serverconfig.FieldExcludedChannels)
	}
	if m.excluded_roles != nil {
		fields = append(fields, serverconfig.FieldExcludedRoles)
	}
	if m.excluded_users != nil {
		fields = append(fields, serverconfig.FieldExcludedUsers)
	}
	if m.given_role != nil {
		fields = append(fields, serverconfig.FieldGivenRole)
	}
	if m.ratelimit_message != nil {
		fields = append(fields, serverconfig.FieldRatelimitMessage)
	}
	if m.ratelimit_time != nil {
		fields = append(fields, serverconfig.FieldRatelimitTime)
	}
	if m.timeout_time != nil {
		fields = append(fields, serverconfig.FieldTimeoutTime)
	}
	if m.ban_delete_message_time != nil {
		fields = append(fields, serverconfig.FieldBanDeleteMessageTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serverconfig.FieldCreateTime:
		return m.CreateTime()
	case serverconfig.FieldUpdateTime:
		return m.UpdateTime()
	case serverconfig.FieldRemoveRoles:
		return m.RemoveRoles()
	case serverconfig.FieldGiveRole:
		return m.GiveRole()
	case serverconfig.FieldTimeout:
		return m.Timeout()
	case serverconfig.FieldKick:
		return m.Kick()
	case serverconfig.FieldBan:
		return m.Ban()
	case serverconfig.FieldCheckInvites:
		return m.CheckInvites()
	case serverconfig.FieldCheckLinks:
		return m.CheckLinks()
	case serverconfig.FieldRatelimit:
		return m.Ratelimit()
	case serverconfig.FieldAlerts:
		return m.Alerts()
	case serverconfig.FieldFlagLinks:
		return m.FlagLinks()
	case serverconfig.FieldLogChannel:
		return m.LogChannel()
	case serverconfig.FieldExcludedChannels:
		return m.ExcludedChannels()
	case serverconfig.FieldExcludedRoles:
		return m.ExcludedRoles()
	case serverconfig.FieldExcludedUsers:
		return m.ExcludedUsers()
	case serverconfig.FieldGivenRole:
		return m.GivenRole()
	case serverconfig.FieldRatelimitMessage:
		return m.RatelimitMessage()
	case serverconfig.FieldRatelimitTime:
		return m.RatelimitTime()
	case serverconfig.FieldTimeoutTime:
		return m.TimeoutTime()
	case serverconfig.FieldBanDeleteMessageTime:
		return m.BanDeleteMessageTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serverconfig.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case serverconfig.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case serverconfig.FieldRemoveRoles:
		return m.OldRemoveRoles(ctx)
	case serverconfig.FieldGiveRole:
		return m.OldGiveRole(ctx)
	case serverconfig.FieldTimeout:
		return m.OldTimeout(ctx)
	case serverconfig.FieldKick:
		return m.OldKick(ctx)
	case serverconfig.FieldBan:
		return m.OldBan(ctx)
	case serverconfig.FieldCheckInvites:
		return m.OldCheckInvites(ctx)
	case serverconfig.FieldCheckLinks:
		return m.OldCheckLinks(ctx)
	case serverconfig.FieldRatelimit:
		return m.OldRatelimit(ctx)
	case serverconfig.FieldAlerts:
		return m.OldAlerts(ctx)
	case serverconfig.FieldFlagLinks:
		return m.OldFlagLinks(ctx)
	case serverconfig.FieldLogChannel:
		return m.OldLogChannel(ctx)
	case serverconfig.FieldExcludedChannels:
		return m.OldExcludedChannels(ctx)
	case serverconfig.FieldExcludedRoles:
		return m.OldExcludedRoles(ctx)
	case serverconfig.FieldExcludedUsers:
		return m.OldExcludedUsers(ctx)
	case serverconfig.FieldGivenRole:
		return m.OldGivenRole(ctx)
	case serverconfig.FieldRatelimitMessage:
		return m.OldRatelimitMessage(ctx)
	case serverconfig.FieldRatelimitTime:
		return m.OldRatelimitTime(ctx)
	case serverconfig.FieldTimeoutTime:
		return m.OldTimeoutTime(ctx)
	case serverconfig.FieldBanDeleteMessageTime:
		return m.OldBanDeleteMessageTime(ctx)
	}
	return nil, fmt.Errorf("unknown ServerConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serverconfig.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case serverconfig.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case serverconfig.FieldRemoveRoles:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoveRoles(v)
		return nil
	case serverconfig.FieldGiveRole:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiveRole(v)
		return nil
	case serverconfig.FieldTimeout:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case serverconfig.FieldKick:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKick(v)
		return nil
	case serverconfig.FieldBan:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBan(v)
		return nil
	case serverconfig.FieldCheckInvites:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckInvites(v)
		return nil
	case serverconfig.FieldCheckLinks:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckLinks(v)
		return nil
	case serverconfig.FieldRatelimit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatelimit(v)
		return nil
	case serverconfig.FieldAlerts:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlerts(v)
		return nil
	case serverconfig.FieldFlagLinks:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlagLinks(v)
		return nil
	case serverconfig.FieldLogChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogChannel(v)
		return nil
	case serverconfig.FieldExcludedChannels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcludedChannels(v)
		return nil
	case serverconfig.FieldExcludedRoles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcludedRoles(v)
		return nil
	case serverconfig.FieldExcludedUsers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcludedUsers(v)
		return nil
	case serverconfig.FieldGivenRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGivenRole(v)
		return nil
	case serverconfig.FieldRatelimitMessage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatelimitMessage(v)
		return nil
	case serverconfig.FieldRatelimitTime:
		v, ok := value.(serverconfig.RatelimitTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatelimitTime(v)
		return nil
	case serverconfig.FieldTimeoutTime:
		v, ok := value.(serverconfig.TimeoutTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeoutTime(v)
		return nil
	case serverconfig.FieldBanDeleteMessageTime:
		v, ok := value.(serverconfig.BanDeleteMessageTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBanDeleteMessageTime(v)
		return nil
	}
	return fmt.Errorf("unknown ServerConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerConfigMutation) AddedFields() []string {
	var fields []string
	if m.addratelimit_message != nil {
		fields = append(fields, serverconfig.FieldRatelimitMessage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case serverconfig.FieldRatelimitMessage:
		return m.AddedRatelimitMessage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case serverconfig.FieldRatelimitMessage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatelimitMessage(v)
		return nil
	}
	return fmt.Errorf("unknown ServerConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServerConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerConfigMutation) ResetField(name string) error {
	switch name {
	case serverconfig.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case serverconfig.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case serverconfig.FieldRemoveRoles:
		m.ResetRemoveRoles()
		return nil
	case serverconfig.FieldGiveRole:
		m.ResetGiveRole()
		return nil
	case serverconfig.FieldTimeout:
		m.ResetTimeout()
		return nil
	case serverconfig.FieldKick:
		m.ResetKick()
		return nil
	case serverconfig.FieldBan:
		m.ResetBan()
		return nil
	case serverconfig.FieldCheckInvites:
		m.ResetCheckInvites()
		return nil
	case serverconfig.FieldCheckLinks:
		m.ResetCheckLinks()
		return nil
	case serverconfig.FieldRatelimit:
		m.ResetRatelimit()
		return nil
	case serverconfig.FieldAlerts:
		m.ResetAlerts()
		return nil
	case serverconfig.FieldFlagLinks:
		m.ResetFlagLinks()
		return nil
	case serverconfig.FieldLogChannel:
		m.ResetLogChannel()
		return nil
	case serverconfig.FieldExcludedChannels:
		m.ResetExcludedChannels()
		return nil
	case serverconfig.FieldExcludedRoles:
		m.ResetExcludedRoles()
		return nil
	case serverconfig.FieldExcludedUsers:
		m.ResetExcludedUsers()
		return nil
	case serverconfig.FieldGivenRole:
		m.ResetGivenRole()
		return nil
	case serverconfig.FieldRatelimitMessage:
		m.ResetRatelimitMessage()
		return nil
	case serverconfig.FieldRatelimitTime:
		m.ResetRatelimitTime()
		return nil
	case serverconfig.FieldTimeoutTime:
		m.ResetTimeoutTime()
		return nil
	case serverconfig.FieldBanDeleteMessageTime:
		m.ResetBanDeleteMessageTime()
		return nil
	}
	return fmt.Errorf("unknown ServerConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.server != nil {
		edges = append(edges, serverconfig.EdgeServer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serverconfig.EdgeServer:
		ids := make([]ent.Value, 0, len(m.server))
		for id := range m.server {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedserver != nil {
		edges = append(edges, serverconfig.EdgeServer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerConfigMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serverconfig.EdgeServer:
		ids := make([]ent.Value, 0, len(m.removedserver))
		for id := range m.removedserver {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedserver {
		edges = append(edges, serverconfig.EdgeServer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case serverconfig.EdgeServer:
		return m.clearedserver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerConfigMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerConfigMutation) ResetEdge(name string) error {
	switch name {
	case serverconfig.EdgeServer:
		m.ResetServer()
		return nil
	}
	return fmt.Errorf("unknown ServerConfig edge %s", name)
}

// WordBlacklistMutation represents an operation that mutates the WordBlacklist nodes in the graph.
type WordBlacklistMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	word          *string
	clearedFields map[string]struct{}
	server        map[string]struct{}
	removedserver map[string]struct{}
	clearedserver bool
	done          bool
	oldValue      func(context.Context) (*WordBlacklist, error)
	predicates    []predicate.WordBlacklist
}

var _ ent.Mutation = (*WordBlacklistMutation)(nil)

// wordblacklistOption allows management of the mutation configuration using functional options.
type wordblacklistOption func(*WordBlacklistMutation)

// newWordBlacklistMutation creates new mutation for the WordBlacklist entity.
func newWordBlacklistMutation(c config, op Op, opts ...wordblacklistOption) *WordBlacklistMutation {
	m := &WordBlacklistMutation{
		config:        c,
		op:            op,
		typ:           TypeWordBlacklist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWordBlacklistID sets the ID field of the mutation.
func withWordBlacklistID(id int) wordblacklistOption {
	return func(m *WordBlacklistMutation) {
		var (
			err   error
			once  sync.Once
			value *WordBlacklist
		)
		m.oldValue = func(ctx context.Context) (*WordBlacklist, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WordBlacklist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWordBlacklist sets the old WordBlacklist of the mutation.
func withWordBlacklist(node *WordBlacklist) wordblacklistOption {
	return func(m *WordBlacklistMutation) {
		m.oldValue = func(context.Context) (*WordBlacklist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WordBlacklistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WordBlacklistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WordBlacklistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WordBlacklistMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WordBlacklist.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *WordBlacklistMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WordBlacklistMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WordBlacklist entity.
// If the WordBlacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordBlacklistMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WordBlacklistMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WordBlacklistMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WordBlacklistMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WordBlacklist entity.
// If the WordBlacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordBlacklistMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WordBlacklistMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetWord sets the "word" field.
func (m *WordBlacklistMutation) SetWord(s string) {
	m.word = &s
}

// Word returns the value of the "word" field in the mutation.
func (m *WordBlacklistMutation) Word() (r string, exists bool) {
	v := m.word
	if v == nil {
		return
	}
	return *v, true
}

// OldWord returns the old "word" field's value of the WordBlacklist entity.
// If the WordBlacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordBlacklistMutation) OldWord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWord: %w", err)
	}
	return oldValue.Word, nil
}

// ResetWord resets all changes to the "word" field.
func (m *WordBlacklistMutation) ResetWord() {
	m.word = nil
}

// AddServerIDs adds the "server" edge to the Server entity by ids.
func (m *WordBlacklistMutation) AddServerIDs(ids ...string) {
	if m.server == nil {
		m.server = make(map[string]struct{})
	}
	for i := range ids {
		m.server[ids[i]] = struct{}{}
	}
}

// ClearServer clears the "server" edge to the Server entity.
func (m *WordBlacklistMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared reports if the "server" edge to the Server entity was cleared.
func (m *WordBlacklistMutation) ServerCleared() bool {
	return m.clearedserver
}

// RemoveServerIDs removes the "server" edge to the Server entity by IDs.
func (m *WordBlacklistMutation) RemoveServerIDs(ids ...string) {
	if m.removedserver == nil {
		m.removedserver = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.server, ids[i])
		m.removedserver[ids[i]] = struct{}{}
	}
}

// RemovedServer returns the removed IDs of the "server" edge to the Server entity.
func (m *WordBlacklistMutation) RemovedServerIDs() (ids []string) {
	for id := range m.removedserver {
		ids = append(ids, id)
	}
	return
}

// ServerIDs returns the "server" edge IDs in the mutation.
func (m *WordBlacklistMutation) ServerIDs() (ids []string) {
	for id := range m.server {
		ids = append(ids, id)
	}
	return
}

// ResetServer resets all changes to the "server" edge.
func (m *WordBlacklistMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
	m.removedserver = nil
}

// Where appends a list predicates to the WordBlacklistMutation builder.
func (m *WordBlacklistMutation) Where(ps ...predicate.WordBlacklist) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WordBlacklistMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WordBlacklistMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WordBlacklist, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WordBlacklistMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WordBlacklistMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WordBlacklist).
func (m *WordBlacklistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WordBlacklistMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, wordblacklist.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, wordblacklist.FieldUpdateTime)
	}
	if m.word != nil {
		fields = append(fields, wordblacklist.FieldWord)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WordBlacklistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wordblacklist.FieldCreateTime:
		return m.CreateTime()
	case wordblacklist.FieldUpdateTime:
		return m.UpdateTime()
	case wordblacklist.FieldWord:
		return m.Word()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WordBlacklistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wordblacklist.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case wordblacklist.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case wordblacklist.FieldWord:
		return m.OldWord(ctx)
	}
	return nil, fmt.Errorf("unknown WordBlacklist field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WordBlacklistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wordblacklist.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case wordblacklist.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case wordblacklist.FieldWord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWord(v)
		return nil
	}
	return fmt.Errorf("unknown WordBlacklist field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WordBlacklistMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WordBlacklistMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WordBlacklistMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WordBlacklist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WordBlacklistMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WordBlacklistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WordBlacklistMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WordBlacklist nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WordBlacklistMutation) ResetField(name string) error {
	switch name {
	case wordblacklist.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case wordblacklist.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case wordblacklist.FieldWord:
		m.ResetWord()
		return nil
	}
	return fmt.Errorf("unknown WordBlacklist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WordBlacklistMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.server != nil {
		edges = append(edges, wordblacklist.EdgeServer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WordBlacklistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wordblacklist.EdgeServer:
		ids := make([]ent.Value, 0, len(m.server))
		for id := range m.server {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WordBlacklistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedserver != nil {
		edges = append(edges, wordblacklist.EdgeServer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WordBlacklistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case wordblacklist.EdgeServer:
		ids := make([]ent.Value, 0, len(m.removedserver))
		for id := range m.removedserver {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WordBlacklistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedserver {
		edges = append(edges, wordblacklist.EdgeServer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WordBlacklistMutation) EdgeCleared(name string) bool {
	switch name {
	case wordblacklist.EdgeServer:
		return m.clearedserver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WordBlacklistMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown WordBlacklist unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WordBlacklistMutation) ResetEdge(name string) error {
	switch name {
	case wordblacklist.EdgeServer:
		m.ResetServer()
		return nil
	}
	return fmt.Errorf("unknown WordBlacklist edge %s", name)
}
